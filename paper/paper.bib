@INPROCEEDINGS{MDH,
  author={Rasch, Ari and Schulze, Richard and Gorlatch, Sergei},
  booktitle={2019 28th International Conference on Parallel Architectures and Compilation Techniques (PACT)},
  title={Generating Portable High-Performance Code via Multi-Dimensional Homomorphisms},
  year={2019},
  volume={},
  number={},
  pages={354-369},
  numpages={16},
  doi={10.1109/PACT.2019.00035}}


@article{BLIS,
   author      = {Field G. {V}an~{Z}ee and Robert A. {v}an~{d}e~{G}eijn},
   title       = {{BLIS}: A Framework for Rapidly Instantiating {BLAS} Functionality},
   journal     = {ACM Transactions on Mathematical Software},
   volume      = {41},
   number      = {3},
   pages       = {14:1--14:33},
   numpages       = {33},
   month       = {June},
   year        = {2015},
   issue_date  = {June 2015},
   url         = {https://doi.acm.org/10.1145/2764454},
}

@article{goto,
    author = {Goto, Kazushige and Geijn, Robert A. van de},
    title = {{A}natomy of {H}igh-{P}erformance {M}atrix {M}ultiplication},
    year = {2008},
    issue_date = {May 2008},
    publisher = {Association for {C}omputing {M}achinery},
    address = {New York, NY, USA},
    volume = {34},
    number = {3},
    issn = {0098-3500},
    url = {https://doi.org/10.1145/1356052.1356053},
    doi = {10.1145/1356052.1356053},
    journal = {ACM Trans. Math. Softw.},
    month = {may},
    articleno = {12},
    numpages = {25},
    keywords = {basic linear algebra subprograms, matrix multiplication, Linear algebra}
}

@INPROCEEDINGS{OpenBLAS,
  author={{W}ang, {Q}ian and {Z}hang, {X}ianyi and {Z}hang, {Y}unquan and {Y}i, {Q}ing},
  booktitle={SC '13: Proceedings of the International Conference on High Performance Computing,
      {N}etworking, Storage and Analysis},
  title={{AUGEM}: {A}utomatically generate high performance {D}ense {L}inear {A}lgebra kernels on
      x86 {CPU}s},
  year={2013},
  volume={},
  number={},
  pages={1-12},
  numpages={12},
  doi={10.1145/2503210.2503219}
}

@misc{paper-src,
    author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo and Koopman, Thomas},
    title = {Sources of {R}ank-{P}olymorphism for {S}hape-{G}uided {B}locking},
    howpublished = {\url{https://gitlab.sac-home.org/sac-group/2023-array}},
    year = {2023}
}

@article{Strassen,
    author = {Strassen, V.},
    journal = {Numerische Mathematik},
    keywords = {numerical analysis},
    pages = {354-356},
    numpages = {3},
    title = {Gaussian Elimination is not Optimal.},
    url = {http://eudml.org/doc/131927},
    volume = {13},
    year = {1969},
}

@INPROCEEDINGS{StrassenReloaded,
  author={Huang, Jianyu and Smith, Tyler M. and Henry, Greg M. and Van De Geijn, Robert A.},
  booktitle={SC '16: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
  title={Strassen's Algorithm Reloaded},
  year={2016},
  volume={},
  number={},
  pages={690-701},
  numpages={12},
  doi={10.1109/SC.2016.58}
}

@inbook{laserMatrix,
    author = {Josh Alman and Virginia Vassilevska Williams},
    title = {A Refined Laser Method and Faster Matrix Multiplication},
    booktitle = {Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms (SODA)},
    chapter = {},
    pages = {522-539},
    numpages = {28},
    year = {2020},
    doi = {10.1137/1.9781611976465.32},
    URL = {https://epubs.siam.org/doi/abs/10.1137/1.9781611976465.32},
    eprint = {https://epubs.siam.org/doi/pdf/10.1137/1.9781611976465.32},
}

@article{BLAS,
  title={An updated set of basic linear algebra subprograms (BLAS)},
  author={Blackford, L Susan and Petitet, Antoine and Pozo, Roldan and Remington, Karin and Whaley, R Clint and Demmel, James and Dongarra, Jack and Duff, Iain and Hammarling, Sven and Henry, Greg and others},
  journal={ACM Transactions on Mathematical Software},
  volume={28},
  number={2},
  pages={135--151},
  numpages={17},
  year={2002}
}

@article{Morton,
    author = {Morton, Guy},
    year = {1966},
    month = {01},
    pages = {},
    title = {A Computer Oriented Geodetic Data Base and a New Technique in File Sequencing}
}

@article{roofline,
    author = {Williams, Samuel and Waterman, Andrew and Patterson, David},
    title = {Roofline: An Insightful Visual Performance Model for Multicore Architectures},
    year = {2009},
    issue_date = {April 2009},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {52},
    number = {4},
    issn = {0001-0782},
    url = {https://doi.org/10.1145/1498765.1498785},
    doi = {10.1145/1498765.1498785},
    abstract = {The Roofline model offers insight on how to improve the performance of software and hardware.},
    journal = {Commun. ACM},
    month = {apr},
    pages = {65–76},
    numpages = {12}
}

@inproceedings{10.1145/567067.567085,
author = {Allen, J. R. and Kennedy, Ken and Porterfield, Carrie and Warren, Joe},
title = {Conversion of Control Dependence to Data Dependence},
year = {1983},
isbn = {0897910907},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/567067.567085},
doi = {10.1145/567067.567085},
abstract = {Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University.},
booktitle = {Proceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {177–189},
numpages = {13},
location = {Austin, Texas},
series = {POPL '83}
}

@article{10.1145/3235029,
author = {Gareev, Roman and Grosser, Tobias and Kruse, Michael},
title = {High-Performance Generalized Tensor Operations: A Compiler-Oriented Approach},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {3},
issn = {1544-3566},
url = {https://doi.org/10.1145/3235029},
doi = {10.1145/3235029},
abstract = {The efficiency of tensor contraction is of great importance. Compilers cannot optimize it well enough to come close to the performance of expert-tuned implementations. All existing approaches that provide competitive performance require optimized external code. We introduce a compiler optimization that reaches the performance of optimized BLAS libraries without the need for an external implementation or automatic tuning. Our approach provides competitive performance across hardware architectures and can be generalized to deliver the same benefits for algebraic path problems. By making fast linear algebra kernels available to everyone, we expect productivity increases when optimized libraries are not available.},
journal = {ACM Trans. Archit. Code Optim.},
month = {sep},
articleno = {34},
numpages = {27},
keywords = {matrix-matrix multiplication, Tensor contractions, high-performance computing}
}


@article{10.1145/3570641,
author = {Tollenaere, Nicolas and Iooss, Guillaume and Pouget, St\'{e}phane and Brunie, Hugo and Guillon, Christophe and Cohen, Albert and Sadayappan, P. and Rastello, Fabrice},
title = {Autotuning Convolutions Is Easier Than You Think},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {2},
issn = {1544-3566},
url = {https://doi.org/10.1145/3570641},
doi = {10.1145/3570641},
abstract = {A wide range of scientific and machine learning applications depend on highly optimized implementations of tensor computations. Exploiting the full capacity of a given processor architecture remains a challenging task, due to the complexity of the microarchitectural features that come into play when seeking near-peak performance. Among the state-of-the-art techniques for loop transformations for performance optimization, AutoScheduler [Zheng et al. 2020a] tends to outperform other systems. It often yields higher performance as compared to vendor libraries, but takes a large number of runs to converge, while also involving a complex training environment. In this article, we define a structured configuration space that enables much faster convergence to high-performance code versions, using only random sampling of candidates. We focus on two-dimensional convolutions on CPUs. Compared to state-of-the-art libraries, our structured search space enables higher performance for typical tensor shapes encountered in convolution stages in deep learning pipelines. Compared to auto-tuning code generators like AutoScheduler, it prunes the search space while increasing the density of efficient implementations. We analyze the impact on convergence speed and performance distribution, on two Intel x86 processors and one ARM AArch64 processor. We match or outperform the performance of the state-of-the-art oneDNN library and TVM’s AutoScheduler, while reducing the autotuning effort by at least an order of magnitude.},
journal = {ACM Trans. Archit. Code Optim.},
month = {mar},
articleno = {20},
numpages = {24},
keywords = {optimisation space, microkernel, convolution, Code generation}
}

@article{CLINTWHALEY20013,
title = {Automated empirical optimizations of software and the ATLAS project},
journal = {Parallel Computing},
volume = {27},
number = {1},
pages = {3-35},
numpages = {33},
year = {2001},
note = {New Trends in High Performance Computing},
issn = {0167-8191},
doi = {https://doi.org/10.1016/S0167-8191(00)00087-9},
url = {https://www.sciencedirect.com/science/article/pii/S0167819100000879},
author = {R. {Clint Whaley} and Antoine Petitet and Jack J. Dongarra},
keywords = {ATLAS, BLAS, Portable performance, AEOS},
}


@inproceedings {Ansor,
author = {Lianmin Zheng and Chengfan Jia and Minmin Sun and Zhao Wu and Cody Hao Yu and Ameer Haj-Ali and Yida Wang and Jun Yang and Danyang Zhuo and Koushik Sen and Joseph E. Gonzalez and Ion Stoica},
title = {Ansor: Generating {High-Performance} Tensor Programs for Deep Learning},
booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
year = {2020},
isbn = {978-1-939133-19-9},
pages = {863--879},
numpages = {17},
url = {https://www.usenix.org/conference/osdi20/presentation/zheng},
publisher = {USENIX Association},
month = nov,
}

@article{10.1145/2858949.2784754,
author = {Steuwer, Michel and Fensch, Christian and Lindley, Sam and Dubach, Christophe},
title = {Generating Performance Portable Code Using Rewrite Rules: From High-Level Functional Expressions to High-Performance OpenCL Code},
year = {2015},
issue_date = {September 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2858949.2784754},
doi = {10.1145/2858949.2784754},
journal = {SIGPLAN Not.},
month = {aug},
pages = {205–217},
numpages = {13},
keywords = {OpenCL, GPU, performance portability, code generation, Algorithmic patterns, rewrite rules}
}



@inproceedings{10.1145/2784731.2784754,
author = {Steuwer, Michel and Fensch, Christian and Lindley, Sam and Dubach, Christophe},
title = {Generating Performance Portable Code Using Rewrite Rules: From High-Level Functional Expressions to High-Performance OpenCL Code},
year = {2015},
isbn = {9781450336697},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2784731.2784754},
doi = {10.1145/2784731.2784754},
booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
pages = {205–217},
numpages = {13},
keywords = {OpenCL, Algorithmic patterns, code generation, GPU, performance portability, rewrite rules},
location = {Vancouver, BC, Canada},
series = {ICFP 2015}
}


@article{10.1145/3150211,
author = {Ragan-Kelley, Jonathan and Adams, Andrew and Sharlet, Dillon and Barnes, Connelly and Paris, Sylvain and Levoy, Marc and Amarasinghe, Saman and Durand, Fr\'{e}do},
title = {Halide: Decoupling Algorithms from Schedules for High-Performance Image Processing},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/3150211},
doi = {10.1145/3150211},
journal = {Commun. ACM},
month = {dec},
pages = {106–115},
numpages = {10}
}

@article{Flame,
author = {Zee, Field G. Van and Bientinesi, Paolo and Low, Tze Meng and Geijn, Robert A. van de},
title = {Scalable Parallelization of FLAME Code via the Workqueuing Model},
year = {2008},
issue_date = {March 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {2},
issn = {0098-3500},
url = {https://doi.org/10.1145/1326548.1326552},
doi = {10.1145/1326548.1326552},
journal = {ACM Trans. Math. Softw.},
month = {mar},
articleno = {10},
numpages = {29},
keywords = {parallel, FLAME, SMP, scalability, workqueuing, OpenMP}
}

@article{10.1145/2925987,
author = {Low, Tze Meng and Igual, Francisco D. and Smith, Tyler M. and Quintana-Orti, Enrique S.},
title = {Analytical Modeling Is Enough for High-Performance BLIS},
year = {2016},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {2},
issn = {0098-3500},
url = {https://doi.org/10.1145/2925987},
doi = {10.1145/2925987},
journal = {ACM Trans. Math. Softw.},
month = {aug},
articleno = {12},
numpages = {18},
keywords = {matrix multiplication, high performance, Linear algebra, libraries, analytical modeling}
}


@article{10.1145/362875.362879,
author = {McKellar, A. C. and Coffman, E. G.},
title = {Organizing Matrices and Matrix Operations for Paged Memory Systems},
year = {1969},
issue_date = {March 1969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/362875.362879},
doi = {10.1145/362875.362879},
journal = {Commun. ACM},
month = {mar},
pages = {153–165},
numpages = {13},
keywords = {virtual memory systems, paged memory systems, storage allocation, paging algorithms, array processing, array storage allocation, matrix algorithms}
}

@article{10.1145/106973.106981,
author = {Lam, Monica D. and Rothberg, Edward E. and Wolf, Michael E.},
title = {The Cache Performance and Optimizations of Blocked Algorithms},
year = {1991},
issue_date = {Apr. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/106973.106981},
doi = {10.1145/106973.106981},
journal = {SIGPLAN Not.},
month = {apr},
pages = {63–74},
numpages = {12}
}



@inproceedings{10.1145/106972.106981,
author = {Lam, Monica D. and Rothberg, Edward E. and Wolf, Michael E.},
title = {The Cache Performance and Optimizations of Blocked Algorithms},
year = {1991},
isbn = {0897913809},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/106972.106981},
doi = {10.1145/106972.106981},
booktitle = {Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {63–74},
numpages = {12},
location = {Santa Clara, California, USA},
series = {ASPLOS IV}
}


@inproceedings{10.1145/258915.258946,
author = {Kodukula, Induprakas and Ahmed, Nawaaz and Pingali, Keshav},
title = {Data-Centric Multi-Level Blocking},
year = {1997},
isbn = {0897919076},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/258915.258946},
doi = {10.1145/258915.258946},
booktitle = {Proceedings of the ACM SIGPLAN 1997 Conference on Programming Language Design and Implementation},
pages = {346–357},
numpages = {12},
location = {Las Vegas, Nevada, USA},
series = {PLDI '97}
}

@article{10.1145/3110251,
    author = {Elliott, Conal},
    title = {Generic Functional Parallel Algorithms: Scan and FFT},
    year = {2017},
    issue_date = {September 2017},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {1},
    number = {ICFP},
    url = {https://doi.org/10.1145/3110251},
    doi = {10.1145/3110251},
    journal = {Proc. ACM Program. Lang.},
    month = {aug},
    articleno = {7},
    numpages = {25},
    keywords = {fast Fourier transform, parallel prefix computation, generic programming}
}

@InProceedings{10.1007/978-3-642-24452-0_6,
author="Trojahner, Kai
and Grelck, Clemens",
editor="Scholz, Sven-Bodo
and Chitil, Olaf",
title="Descriptor-Free Representation of Arrays with Dependent Types",
booktitle="Implementation and Application of Functional Languages",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="100--117",
numpages={18},
isbn="978-3-642-24452-0"
}

@inproceedings{10.1145/277650.277732,
author = {Xi, Hongwei and Pfenning, Frank},
title = {Eliminating Array Bound Checking through Dependent Types},
year = {1998},
isbn = {0897919874},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/277650.277732},
doi = {10.1145/277650.277732},
booktitle = {Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation},
pages = {249–257},
numpages = {9},
location = {Montreal, Quebec, Canada},
series = {PLDI '98}
}

@InProceedings{10.1007/978-3-642-54833-8_3,
author="Slepak, Justin
and Shivers, Olin
and Manolios, Panagiotis",
editor="Shao, Zhong",
title="An Array-Oriented Language with Static Rank Polymorphism",
booktitle="Programming Languages and Systems",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="27--46",
numpages={20},
isbn="978-3-642-54833-8"
}

@inproceedings{10.1145/3460944.3464310,
author = {Henriksen, Troels and Elsman, Martin},
title = {Towards Size-Dependent Types for Array Programming},
year = {2021},
isbn = {9781450384667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3460944.3464310},
doi = {10.1145/3460944.3464310},
abstract = {We present a type system for expressing size constraints on array types in an ML-style type system. The goal is to detect shape mismatches at compile-time, while being simpler than full dependent types. The main restrictions is that the only terms that can occur in types are array sizes, and syntactically they must be variables or constants. For those programs where this is not sufficient, we support a form of existential types, with the type system automatically managing the requisite book-keeping. We formalise a large subset of the type system in a small core language, which we prove sound. We also present an integration of the type system in the high-performance parallel functional language Futhark, and show on a collection of 44 representative programs that the restrictions in the type system are not too problematic in practice.},
booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
pages = {1–14},
numpages = {14},
keywords = {parallel programming, type systems, functional programming},
location = {Virtual, Canada},
series = {ARRAY 2021}
}

@inproceedings{10.1145/3609024.3609412,
author = {Bailly, Lubin and Henriksen, Troels and Elsman, Martin},
title = {Shape-Constrained Array Programming with Size-Dependent Types},
year = {2023},
isbn = {9798400702969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3609024.3609412},
doi = {10.1145/3609024.3609412},
abstract = {We present a dependent type system for enforcing array-size consistency in an ML-style functional array language. Our goal is to enforce shape-consistency at compile time and allow nontrivial transformations on array shapes, without the complexity such features tend to introduce in dependently typed languages. Sizes can be arbitrary expressions and size equality is purely syntactical, which fits naturally within a scheme that interprets size-polymorphic functions as having implicit arguments. When non-syntactical equalities are needed, we provide dynamic checking. In contrast to other dependently typed languages, we automate the book-keeping involved in tracking existential sizes, such as when filtering arrays. We formalise a large subset of the presented type system and prove it sound. We also discuss how to adapt the type system for a real implementation, including type inference, within the Futhark programming language.},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Workshop on Functional High-Performance and Numerical Computing},
pages = {29â€“41},
numpages = {13},
keywords = {type systems, parallel programming, functional programming},
location = {Seattle, WA, USA},
series = {FHPNC 2023}
}



@inproceedings{2020-msfp,
  author    = {Artjoms {\v{S}}inkarovs},
  editor    = {Max S. New and
               Sam Lindley},
  title     = {Multi-dimensional Arrays with Levels},
  booktitle = {Proceedings Eighth Workshop on Mathematically Structured Functional
               Programming, MSFP@ETAPS 2020, Dublin, Ireland, 25th April 2020},
  series    = {{EPTCS}},
  volume    = {317},
  pages     = {57--71},
  numpages  = {15},
  year      = {2020},
  url       = {https://doi.org/10.4204/EPTCS.317.4},
  doi       = {10.4204/EPTCS.317.4},
  timestamp = {Fri, 08 May 2020 16:00:57 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2005-00198.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{abs-2105-10819,
  author       = {Artjoms Sinkarovs and
                  Jesper Cockx},
  title        = {Choosing is Losing: How to combine the benefits of shallow and deep
                  embeddings through reflection},
  journal      = {CoRR},
  volume       = {abs/2105.10819},
  year         = {2021},
  url          = {https://arxiv.org/abs/2105.10819},
  eprinttype    = {arXiv},
  eprint       = {2105.10819},
  timestamp    = {Mon, 31 May 2021 16:16:57 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2105-10819.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{10.1145/3520306.3534500,
    author = {\v{S}inkarovs, Artjoms and Scholz, Sven-Bodo},
    title = {Parallel Scan as a Multidimensional Array Problem},
    year = {2022},
    isbn = {9781450392693},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3520306.3534500},
    doi = {10.1145/3520306.3534500},
    abstract = {For many algorithms, it is challenging to identify a suitable parallel version, as the design space is typically very large. In this paper we demonstrate how rank-polymorphic array languages can be used as a tool to explore such design spaces through concise high-level specifications. If input data can be organised into a multi-dimensional array, and the algorithm can be stated as a recursive traversal over sub-arrays, array languages offer a lot of expressive power. The reason for this is that array shapes can be used to guide recursive traversals. Conciseness of specifications comes from array reshapes that move the desired elements into canonical hyperplanes. As a case study, we discuss several variants of implementing prefix sums (also known as scans) in SaC. We demonstrate how small code adjustments suffice to change the concurrency pattern exposed to the compiler. It turns out that variability that is typically achieved by generic inductive data types such as binary trees is a special case of what is offered by the array paradigm.},
    booktitle = {Proceedings of the 8th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
    pages = {1–11},
    numpages = {11},
    keywords = {functional programming, rank polymorphism, algorithms, array languages, parallelism, prefix sum},
    location = {San Diego, CA, USA},
    series = {ARRAY 2022}
}

@INPROCEEDINGS{polyhedral,
  author={Pouchet, Louis-Noel and Bastoul, Cedric and Cohen, Albert and Vasilache, Nicolas},
  booktitle={International Symposium on Code Generation and Optimization (CGO'07)},
  title={Iterative Optimization in the Polyhedral Model: Part I, One-Dimensional Time},
  year={2007},
  volume={},
  number={},
  pages={144-156},
  numpages={13},
  abstract={Emerging microprocessors offer unprecedented parallel computing capabilities and deeper memory hierarchies, increasing the importance of loop transformations in optimizing compilers. Because compiler heuristics rely on simplistic performance models, and because they are bound to a limited set of transformations sequences, they only uncover a fraction of the peak performance on typical benchmarks. Iterative optimization is a maturing framework to address these limitations, but so far, it was not successfully applied complex loop transformation sequences because of the combinatorics of the optimization search space. We focus on the class of loop transformation which can be expressed as one-dimensional affine schedules. We define a systematic exploration method to enumerate the space of all legal, distinct transformations in this class. This method is based on an upstream characterization, as opposed to state-of-the-art downstream filtering approaches. Our results demonstrate orders of magnitude improvements in the size of the search space and in the convergence speed of a dedicated iterative optimization heuristic},
  keywords={},
  doi={10.1109/CGO.2007.21},
  ISSN={},
  month={March},
}

@misc{gratzer2022controlling,
      title={Controlling unfolding in type theory},
      author={Daniel Gratzer and Jonathan Sterling and Carlo Angiuli and Thierry Coquand and Lars Birkedal},
      year={2022},
      eprint={2210.05420},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}

@misc{gccExtension,
    author= {{GNU Project}},
    title = {{U}sing {V}ector {I}nstructions through {B}uilt-in {F}unctions},
    note  = {\url{https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html},
             Last accessed on 2023-05-30},
}

@InProceedings{withFolding,
  author     = {Sven-Bodo Scholz},
  title      = {With-loop-folding in Sac --- Condensing Consecutive Array Operations},
  booktitle  = {Implementation of Functional Languages, 9th International Workshop (IFL'97), St. Andrews, UK, Selected Papers},
  year       = {1998},
  editor     = {Chris Clack and Tony Davie and Kevin Hammond},
  volume     = {1467},
  series     = {Lecture Notes in Computer Science},
  pages      = {72--92},
  numpages   = {21},
  publisher  = {Springer},
  category   = {core,design,opt},
  doi        = {10.1007/BFb0055425},
  isbn       = {978-3-540-64849-9},
  pubaddress = {Berlin, Heidelberg, Germany},
  topics     = {SAC,Avoiding Temporaries,Implementation of Arrays},
  url        = {wlf-st-andrews-97.pdf},
}

@inproceedings{cpcgcc,
  Author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo},
  Title = {Portable Support for Explicit Vectorisation in C},
  BookTitle = {16th Workshop on Compilers for Parallel
  Computing (CPC'12)},
  Year = {2012}
}

@inproceedings{10.1145/3412932.3412947,
author = {Scholz, Sven-Bodo and \v{S}inkarovs, Artjoms},
title = {Tensor Comprehensions in SaC},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412947},
doi = {10.1145/3412932.3412947},
abstract = {We propose a new notation for data parallel operators on multi-dimensional arrays named tensor comprehensions. This notation combines the basic principle of array-comprehensions with syntactical shortcuts very close to those found in the so-called Tensor Notations used in Physics and Mathematics. As a result, complex operators with rich semantics can be defined concisely. The key to this conciseness lies in the ability to define shape-polymorphic operations combined with the ability to infer array shapes from the immediate context. The paper provides a definition of the proposed notation, a formal shape inference process, as well as a set of re-write rules that translates tensor comprehensions as a zero-cost syntactic sugar into standard SaC expressions.},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {15},
numpages = {13},
location = {Singapore, Singapore},
series = {IFL '19}
}

@misc{MKL,
    author= {{Intel}},
    title = {{I}ntel one{API} {M}ath {K}ernel {L}ibrary},
    note  = {\url{https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html},
             Last accessed on 2023-05-31},
}

@INPROCEEDINGS{sequoia,
  author={Fatahalian, Kayvon and Knight, Timothy J. and Houston, Mike and Erez, Mattan and Horn, Daniel Reiter and Leem, Larkhoon and Park, Ji Young and Ren, Manman and Aiken, Alex and Dally, William J. and Hanrahan, Pat},

  booktitle={SC '06: Proceedings of the 2006 ACM/IEEE Conference on Supercomputing},

  title={Sequoia: Programming the Memory Hierarchy},

  year={2006},

  volume={},

  number={},

  pages={4-4},

  numpages={1},

  doi={10.1109/SC.2006.55}
}

@misc{artefact,
    author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo and Koopman, Thomas},
    title = {Artefact for {R}ank-{P}olymorphism for {S}hape-{G}uided {B}locking},
    DOI = {10.1145/3580402},
    year = {2023}
}

@inproceedings{cnn-array,
author = {\v{S}inkarovs, Artjoms and Vie\ss{}mann, Hans-Nikolai and Scholz, Sven-Bodo},
title = {Array languages make neural networks fast},
year = {2021},
isbn = {9781450384667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3460944.3464312},
doi = {10.1145/3460944.3464312},
booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
pages = {39–50},
numpages = {12},
keywords = {machine learning, array language},
location = {Virtual, Canada},
series = {ARRAY 2021}
}


@article{ix-containers,
title={Indexed containers},
volume={25},
DOI={10.1017/S095679681500009X},
journal={Journal of Functional Programming},
author={Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
year={2015},
pages={e5}
}


@inproceedings{subst,
author = {Keller, Chantal and Altenkirch, Thorsten},
title = {Hereditary substitutions for simple types, formalized},
year = {2010},
isbn = {9781450302555},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863597.1863601},
doi = {10.1145/1863597.1863601},
booktitle = {Proceedings of the Third ACM SIGPLAN Workshop on Mathematically Structured Functional Programming},
pages = {3–10},
numpages = {8},
keywords = {decidability of Βη-equality, hereditary substitutions, normalizer, type theory},
location = {Baltimore, Maryland, USA},
series = {MSFP '10}
}

@InProceedings{nbe1,
  author =	{Altenkirch, Thorsten and Kaposi, Ambrus},
  title =	{{Normalisation by Evaluation for Dependent Types}},
  booktitle =	{1st International Conference on Formal Structures for Computation and Deduction (FSCD 2016)},
  pages =	{6:1--6:16},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-010-1},
  ISSN =	{1868-8969},
  year =	{2016},
  volume =	{52},
  editor =	{Kesner, Delia and Pientka, Brigitte},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2016.6},
  URN =		{urn:nbn:de:0030-drops-59727},
  doi =		{10.4230/LIPIcs.FSCD.2016.6},
  annote =	{Keywords: normalisation by evaluation, dependent types, internal type theory, logical relations, Agda}
}

@article{par-sub1,
  title={Explicit substitutions},
  volume={1},
  DOI={10.1017/S0956796800000186},
  number={4},
  journal={Journal of Functional Programming},
  author={Abadi, M. and Cardelli, L. and Curien, P.-L. and Lévy, J.-J.},
  year={1991},
  pages={375–416}
}

@InProceedings{par-sub2,
author="Sch{\"a}fer, Steven
and Tebbi, Tobias
and Smolka, Gert",
editor="Urban, Christian
and Zhang, Xingyuan",
title="Autosubst: Reasoning with de Bruijn Terms and Parallel Substitutions",
booktitle="Interactive Theorem Proving",
year="2015",
publisher="Springer International Publishing",
address="Cham",
pages="359--374",
abstract="Reasoning about syntax with binders plays an essential role in the formalization of the metatheory of programming languages. While the intricacies of binders can be ignored in paper proofs, formalizations involving binders tend to be heavyweight. We present a discipline for syntax with binders based on de Bruijn terms and parallel substitutions, with a decision procedure covering all assumption-free equational substitution lemmas. The approach is implemented in the Coq library Autosubst, which additionally derives substitution operations and proofs of substitution lemmas for custom term types. We demonstrate the effectiveness of the approach with several case studies, including part A of the POPLmark challenge.",
isbn="978-3-319-22102-1"
}

@inproceedings{rp-mm,
author = {\v{S}inkarovs, Artjoms and Koopman, Thomas and Scholz, Sven-Bodo},
title = {Rank-Polymorphism for Shape-Guided Blocking},
year = {2023},
isbn = {9798400702969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3609024.3609410},
doi = {10.1145/3609024.3609410},
abstract = {Many numerical algorithms on matrices or tensors can be formulated in a blocking style which improves performance due to better cache locality. In imperative languages, blocking is achieved by introducing additional layers of loops in a nested fashion alongside with suitable adjustments in index computations. While this process is tedious and error-prone, it is also difficult to implement a generically blocked version that would support arbitrary levels of blocking. At the example of matrix multiply, this paper demonstrates how rank-polymorphic array languages enable the specification of such generically blocked algorithms in a simple, recursive form. The depth of the blocking as well as blocking factors can be encoded in the structure of array shapes. In turn, reshaping arrays makes it possible to switch between blocked and non-blocked arrays. Through rank-polymorphic array combinators, any specification of loop boundaries or explicit index computations can be avoided. Firstly, we propose a dependently-typed framework for rank-polymorphic arrays. We use it to demonstrate that all blocked algorithms can be naturally derived by induction on the argument shapes. Our framework guarantees lack of out-of-bound indexing, and we also prove that all the blocked versions compute the same results as the canonical algorithm. Secondly, we translate our specification to the array language SaC. Not only do we show that we achieve similar conciseness in the implementation, but we also observe good performance of the generated code. We achieve a 7\% improvement compared to the highly-optimised OpenBLAS library, and 3\% compared to Intel’s MKL library when running on a 32-core shared-memory system.},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Workshop on Functional High-Performance and Numerical Computing},
pages = {1–14},
numpages = {14},
keywords = {Array Programming, Dependent Types, HPC, Matrix Multiply, Rank-Polymorphism},
location = {Seattle, WA, USA},
series = {FHPNC 2023}
}

@INPROCEEDINGS{nbe2,
  author={Abel, Andreas and Coquand, Thierry and Dybjer, Peter},
  booktitle={22nd Annual IEEE Symposium on Logic in Computer Science (LICS 2007)}, 
  title={Normalization by Evaluation for Martin-Löf Type Theory with Typed Equality Judgements}, 
  year={2007},
  volume={},
  number={},
  pages={3-12},
  keywords={Computer science;Calculus;Buildings;Decision feedback equalizers;Mathematical model;Application software;Logic},
  doi={10.1109/LICS.2007.33}
}


@inproceedings{hoas,
  author = {Pfenning, F. and Elliott, C.},
  title = {Higher-order abstract syntax},
  year = {1988},
  isbn = {0897912691},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/53990.54010},
  doi = {10.1145/53990.54010},
  booktitle = {Proceedings of the ACM SIGPLAN 1988 Conference on Programming Language Design and Implementation},
  pages = {199–208},
  numpages = {10},
  location = {Atlanta, Georgia, USA},
  series = {PLDI '88}
}

@article{backprop-stlc,
author = {Brunel, Alo\"{\i}s and Mazza, Damiano and Pagani, Michele},
title = {Backpropagation in the simply typed lambda-calculus with linear negation},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371132},
doi = {10.1145/3371132},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {64},
numpages = {27},
keywords = {Differentiable Programming, Lambda-Calculus, Linear Logic}
}


@article{autodiff-survey,
author = {Baydin, At\i{}l\i{}m G\"{u}nes and Pearlmutter, Barak A. and Radul, Alexey Andreyevich and Siskind, Jeffrey Mark},
title = {Automatic differentiation in machine learning: a survey},
year = {2017},
issue_date = {January 2017},
publisher = {JMLR.org},
volume = {18},
number = {1},
issn = {1532-4435},
journal = {J. Mach. Learn. Res.},
month = {jan},
pages = {5595–5637},
numpages = {43},
keywords = {differentiable programming, backpropagation}
}
       
@inproceedings{tensor-comp,
author = {Scholz, Sven-Bodo and \v{S}inkarovs, Artjoms},
title = {Tensor comprehensions in SaC},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412947},
doi = {10.1145/3412932.3412947},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {15},
numpages = {13},
location = {Singapore, Singapore},
series = {IFL '19}
}

@article{early-ad1,
author = {Hanson, James W. and Caviness, Jane Shearin and Joseph, Camilla},
title = {Analytic differentiation by computer},
year = {1962},
issue_date = {June 1962},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {6},
issn = {0001-0782},
url = {https://doi.org/10.1145/367766.368195},
doi = {10.1145/367766.368195},
abstract = {During the past few years a major portion of the work in computer applications has been concentrated in the two closely related fields of automatic programming and symbol manipulation. The results of this effort have been a wealth of new computer languages, a better understanding and definition of the basic principles and problems of symbol manipulation, and a growing body of algorithms and techniques for use in the applications.},
journal = {Commun. ACM},
month = {jun},
pages = {349–355},
numpages = {7}
}

@MASTERSTHESIS{early-ad2,
       author = "Nolan, J. F.",
       title = "Analytical Differentiation on a Digital Computer",
       school = "Massachusetts Institute of Technology",
       year = "1953",
       month = "May",
}

@inproceedings {futhark/sc22ad,
author = {R. Schenck and O. RÃ¸nning and T. Henriksen and C. E. Oancea},
booktitle = {2022 SC22: International Conference for High Performance Computing, Networking, Storage and Analysis (SC) (SC)},
title = {AD for an Array Language with Nested Parallelism},
year = {2022},
volume = {},
issn = {2167-4337},
pages = {829-843},
abstract = {We present a technique for applying reverse mode automatic differentiation (AD) on a non-recursive second-order functional array language that supports nested parallelism and is primarily aimed at efficient GPU execution. The key idea is to eliminate the need for a tape by relying on redundant execution to bring into each new scope all program variables that may be needed by the differentiated code. Efficient execution is enabled by the observation that perfectly nested scopes do not introduce re-execution and that such perfect nests can be readily produced by application of known compiler transformations. Our technique differentiates loops and bulk-parallel operatorsâ€”e.g., map, reduce(-by-index), scan, and scatterâ€”by specific rewrite rules and aggressively optimizes the resulting nested-parallel code. We report an evaluation that compares with established AD solutions and demonstrates competitive performance on ten common benchmarks from recent applied AD literature.},
keywords = {automatic differentiation;functional data parallel language;compilers;gpgpu},
doi = {},
url = {https://doi.ieeecomputersociety.org/},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {nov}
}

@article{ad-haskell,
author = {Krawiec, Faustyna and Peyton Jones, Simon and Krishnaswami, Neel and Ellis, Tom and Eisenberg, Richard A. and Fitzgibbon, Andrew},
title = {Provably correct, asymptotically efficient, higher-order reverse-mode automatic differentiation},
year = {2022},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {POPL},
url = {https://doi.org/10.1145/3498710},
doi = {10.1145/3498710},
abstract = {In this paper, we give a simple and efficient implementation of reverse-mode automatic differentiation, which both extends easily to higher-order functions, and has run time and memory consumption linear in the run time of the original program. In addition to a formal description of the translation, we also describe an implementation of this algorithm, and prove its correctness by means of a logical relations argument.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {48},
numpages = {30},
keywords = {Wengert List, Reverse-Mode AD, Higher-Order Functions}
}

@inproceedings{
ad-jax,
title={Automatic Functional Differentiation in {JAX}},
author={Min Lin},
booktitle={The Twelfth International Conference on Learning Representations},
year={2024},
url={https://openreview.net/forum?id=gzT61ziSCu}
}

@inproceedings{ad-tf,
  title={Tensorflow: A system for large-scale machine learning},
  author={Abadi, Mart{\'\i}n and Barham, Paul and Chen, Jianmin and Chen, Zhifeng and Davis, Andy and Dean, Jeffrey and Devin, Matthieu and Ghemawat, Sanjay and Irving, Geoffrey and Isard, Michael and others},
  booktitle={12th $\{$USENIX$\}$ Symposium on Operating Systems Design and Implementation ($\{$OSDI$\}$ 16)},
  pages={265--283},
  year={2016}
}

@inbook{ad-pytorch,
author = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and K\"{o}pf, Andreas and Yang, Edward and DeVito, Zach and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith},
title = {PyTorch: an imperative style, high-performance deep learning library},
year = {2019},
publisher = {Curran Associates Inc.},
address = {Red Hook, NY, USA},
abstract = {Deep learning frameworks have often focused on either usability or speed, but not both. PyTorch is a machine learning library that shows that these two goals are in fact compatible: it provides an imperative and Pythonic programming style that supports code as a model, makes debugging easy and is consistent with other popular scientific computing libraries, while remaining efficient and supporting hardware accelerators such as GPUs.In this paper, we detail the principles that drove the implementation of PyTorch and how they are reflected in its architecture. We emphasize that every aspect of PyTorch is a regular Python program under the full control of its user. We also explain how the careful and pragmatic implementation of the key components of its runtime enables them to work together to achieve compelling performance. We demonstrate the efficiency of individual subsystems, as well as the overall speed of PyTorch on several common benchmarks.},
booktitle = {Proceedings of the 33rd International Conference on Neural Information Processing Systems},
articleno = {721},
numpages = {12}
}

  
@misc{ad-mxnet,
      title={MXNet: A Flexible and Efficient Machine Learning Library for Heterogeneous Distributed Systems}, 
      author={Tianqi Chen and Mu Li and Yutian Li and Min Lin and Naiyan Wang and Minjie Wang and Tianjun Xiao and Bing Xu and Chiyuan Zhang and Zheng Zhang},
      year={2015},
      eprint={1512.01274},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}


@InProceedings{ad-theor1,
author="Cruttwell, Geoffrey S. H.
and Gavranovi{\'{c}}, Bruno
and Ghani, Neil
and Wilson, Paul
and Zanasi, Fabio",
editor="Sergey, Ilya",
title="Categorical Foundations of Gradient-Based Learning",
booktitle="Programming Languages and Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="1--28",
abstract="We propose a categorical semantics of gradient-based machine learning algorithms in terms of lenses, parametric maps, and reverse derivative categories. This foundation provides a powerful explanatory and unifying framework: it encompasses a variety of gradient descent algorithms such as ADAM, AdaGrad, and Nesterov momentum, as well as a variety of loss functions such as MSE and Softmax cross-entropy, shedding new light on their similarities and differences. Our approach to gradient-based learning has examples generalising beyond the familiar continuous domains (modelled in categories of smooth maps) and can be realized in the discrete setting of boolean circuits. Finally, we demonstrate the practical significance of our framework with an implementation in Python.",
isbn="978-3-030-99336-8"
}

@inproceedings{ad-theor2,
    author = {Fong, Brendan and Spivak, David and Tuy\'{e}ras, R\'{e}my},
    title = {Backprop as functor: a compositional perspective on supervised learning},
    year = {2021},
    publisher = {IEEE Press},
    abstract = {A supervised learning algorithm searches over a set of functions A → B parametrised by a space P to find the best approximation to some ideal function f: A → B. It does this by taking examples (a,f(a)) ∈ A \texttimes{} B, and updating the parameter according to some rule. We define a category where these update rules may be composed, and show that gradient descent---with respect to a fixed step size and an error function satisfying a certain property---defines a monoidal functor from a category of parametrised functions to this category of update rules. A key contribution is the notion of request function. This provides a structural perspective on backpropagation, giving a broad generalisation of neural networks and linking it with structures from bidirectional programming and open games.},
    booktitle = {Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science},
    articleno = {11},
    numpages = {13},
    location = {Vancouver, Canada},
    series = {LICS '19}
}

      

@article{ad-theor3,
title = {Forward- or reverse-mode automatic differentiation: What's the difference?},
journal = {Science of Computer Programming},
volume = {231},
pages = {103010},
year = {2024},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2023.103010},
url = {https://www.sciencedirect.com/science/article/pii/S0167642323000928},
author = {Birthe {van den Berg} and Tom Schrijvers and James McKinna and Alexander Vandenbroucke},
keywords = {Automatic differentiation, Cayley representation, Semimodules, Nagata idealization, Kronecker},
}

@article{ad-elliott,
    author = {Elliott, Conal},
    title = {The simple essence of automatic differentiation},
    year = {2018},
    issue_date = {September 2018},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {ICFP},
    url = {https://doi.org/10.1145/3236765},
    doi = {10.1145/3236765},
    journal = {Proc. ACM Program. Lang.},
    month = {jul},
    articleno = {70},
    numpages = {29},
    keywords = {program calculation, category theory, automatic differentiation}
}

      

@article{sac1,
  title={Shared memory multiprocessor support for functional array processing in SAC},
  volume={15},
  DOI={10.1017/S0956796805005538},
  number={3},
  journal={Journal of Functional Programming},
  author={Grelck, Clemens},
  year={2005},
  pages={353–401}
}


@article{sac2,
  title={Single Assignment C: efficient support for high-level array operations in a functional setting},
  volume={13},
  DOI={10.1017/S0956796802004458},
  number={6},
  journal={Journal of Functional Programming},
  author={Scholz, Sven-Bodo},
  year={2003},
  pages={1005–1059}
}


@Manual{agda-2-6-3,
  title = {Agda 2.6.3 documentation},
  author = {{Agda Development Team}},
  year = 2024,
  url = "https://agda.readthedocs.io/en/v2.6.3/",
  note = {Accessed [2024/02/28]},
}

@inproceedings{rank-poly,
author = {Slepak, Justin and Shivers, Olin and Manolios, Panagiotis},
title = {An Array-Oriented Language with Static Rank Polymorphism},
year = {2014},
isbn = {9783642548321},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-54833-8_3},
doi = {10.1007/978-3-642-54833-8_3},
abstract = {The array-computational model pioneered by Iverson's languages APL and J offers a simple and expressive solution to the "von Neumann bottleneck." It includes a form of rank, or dimensional, polymorphism, which renders much of a program's control structure implicit by lifting base operators to higher-dimensional array structures. We present the first formal semantics for this model, along with the first static type system that captures the full power of the core language.The formal dynamic semantics of our core language, Remora, illuminates several of the murkier corners of the model. This allows us to resolve some of the model's ad hoc elements in more general, regular ways. Among these, we can generalise the model from SIMD to MIMD computations, by extending the semantics to permit functions to be lifted to higher-dimensional arrays in the same way as their arguments.Our static semantics, a dependent type system of carefully restricted power, is capable of describing array computations whose dimensions cannot be determined statically. The type-checking problem is decidable and the type system is accompanied by the usual soundness theorems. Our type system's principal contribution is that it serves to extract the implicit control structure that provides so much of the language's expressive power, making this structure explicitly apparent at compile time.},
booktitle = {Proceedings of the 23rd European Symposium on Programming Languages and Systems - Volume 8410},
pages = {27–46},
numpages = {20}
}


@article{applicative,
  title={Applicative programming with effects},
  volume={18},
  DOI={10.1017/S0956796807006326},
  number={1},
  journal={Journal of Functional Programming},
  author={McBride, Conor and Paterson, Ross},
  year={2008},
  pages={1–13}
}

@inproceedings{type-pattern,
author={Aaldering, Jordy and Scholz, Sven-Bodo and Van Gastel, Bernard},
title={Type Patterns: Pattern Matching on Shape-Carrying Array Types},
publisher={Association for Computing Machinery},
address={New York, NY, USA},
booktitle={Proceedings of the 35st Symposium on Implementation and Application of Functional Languages},
series={IFL '23},
year={2024},
note={(to appear)},
keywords={Array Programming, Single assignment C, Rank-Polymorphism, Hybrid Types, Dependent Types, Type Constraints, Partial Evaluation, Pattern Matching, Shape Pattern, Type Pattern},
abstract={In this paper we present type patterns: a notation for shape-carrying array types that enables the specification of dependent type signatures while maintaining flexibility and a high level of code readability. Similar notations pre-exist, but we extend them to support rank-polymorphism and specifications of arbitrarily complex constraints between values and types. Furthermore, we enable type patterns to double as a pattern matching mechanism against shapes and shape-components of array arguments, making those values directly available in the respective function bodies. While this notation could be used as a basis for a dependently typed language, in our prototypical implementation in the context of SaC we do not require all dependencies to be resolved statically. Instead, we follow a hybrid approach: we map the proposed type patterns into the pre-existing type system of SaC, and we generate additional constraints which we try to statically resolve as far as possible by means of partial evaluation. Any remaining constraints are checked at run-time. We outline our implementation in the context of the SaC ecosystem, and present several examples demonstrating the effectiveness of this hybrid approach based on partial evaluation.}
}

@InProceedings{wlf,
  author     = {Sven-Bodo Scholz},
  title      = {With-loop-folding in Sac --- Condensing Consecutive Array Operations},
  booktitle  = {Implementation of Functional Languages, 9th International Workshop (IFL'97), St. Andrews, UK, Selected Papers},
  year       = {1998},
  editor     = {Chris Clack and Tony Davie and Kevin Hammond},
  volume     = {1467},
  series     = {Lecture Notes in Computer Science},
  pages      = {72--92},
  publisher  = {Springer},
  abstract   = {This paper introduces a new compiler optimization called With-loop-folding. It is based on a special loop construct, the with-loop, which in the functional language SAC (for Single Assignment C) serves as a versatile vehicle to describe array operations on an elementwise basis. A general mechanism for combining two of these With-loops into a single loop construct is presented. This mechanism constitutes a powerful tool when it comes to generate efficiently executable code from high-level array specifications. By means of a few examples it is shown that even complex nestings of array operations similar to those available in Apl can be transformed into single loop operations which are similar to hand-optimized With-loop specifications. As a consequence, the way a complex array operation is combined from primitive array operations does not affect the runtime performance of the compiled code, i.e., the programmer is liberated from the burden to take performance considerations into account when specifying complex array operations.},
  category   = {core,design,opt},
  doi        = {10.1007/BFb0055425},
  isbn       = {978-3-540-64849-9},
  pubaddress = {Berlin, Heidelberg, Germany},
  topics     = {SAC,Avoiding Temporaries,Implementation of Arrays},
  url        = {wlf-st-andrews-97.pdf},
}


@article{deng2012mnist,
  title={The mnist database of handwritten digit images for machine learning research},
  author={Deng, Li},
  journal={IEEE Signal Processing Magazine},
  volume={29},
  number={6},
  pages={141--142},
  year={2012},
  publisher={IEEE}
}

@article{10.1145/3498717,
author = {Liu, Amanda and Bernstein, Gilbert Louis and Chlipala, Adam and Ragan-Kelley, Jonathan},
title = {Verified tensor-program optimization via high-level scheduling rewrites},
year = {2022},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {POPL},
url = {https://doi.org/10.1145/3498717},
doi = {10.1145/3498717},
abstract = {We present a lightweight Coq framework for optimizing tensor kernels written in a pure, functional array language. Optimizations rely on user scheduling using series of verified, semantics-preserving rewrites. Unusually for compilation targeting imperative code with arrays and nested loops, all rewrites are source-to-source within a purely functional language. Our language comprises a set of core constructs for expressing high-level computation detail and a set of what we call reshape operators, which can be derived from core constructs but trigger low-level decisions about storage patterns and ordering. We demonstrate that not only is this system capable of deriving the optimizations of existing state-of-the-art languages like Halide and generating comparably performant code, it is also able to schedule a family of useful program transformations beyond what is reachable in Halide.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {55},
numpages = {28},
keywords = {array programming, formal verification, optimization, proof assistants}
}

@article{10.1145/3527328,
author = {Cl\'{e}ment, Basile and Cohen, Albert},
title = {End-to-end translation validation for the {Halide} language},
year = {2022},
issue_date = {April 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3527328},
doi = {10.1145/3527328},
abstract = {This paper considers the correctness of domain-specific compilers for tensor programming languages through the study of Halide, a popular representative. It describes a translation validation algorithm for affine Halide specifications, independently of the scheduling language. The algorithm relies on “prophetic” annotations added by the compiler to the generated array assignments. The annotations provide a refinement mapping from assignments in the generated code to the tensor definitions from the specification. Our implementation leverages an affine solver and a general SMT solver, and scales to complete Halide benchmarks.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {84},
numpages = {30},
keywords = {Domain-specific Languages, Formal semantics, Polyhedral Compilers, Tensor Compilers, Validation}
}

@inproceedings{10.1145/2976022.2976023,
author = {Gibbons, Jeremy},
title = {{APL}icative programming with Naperian functors (extended abstract)},
year = {2016},
isbn = {9781450344357},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2976022.2976023},
doi = {10.1145/2976022.2976023},
abstract = {A lot of the expressive power of array-oriented languages such as Iverson's APL and J comes from their implicit lifting of scalar operations to act on higher-ranked data, for example to add a value to each element of a vector, or to add two compatible matrices pointwise. But it is a shape error to attempt to combine arguments of incompatible shape, such as a 3-vector with a 4-vector. APL and J are dynamically typed, so such shape errors are caught only at run-time. Recent work by Slepak et al. develops a custom static type system for an array-oriented language. We show here that such a custom language design is unnecessary; the requisite compatibility checks can already be captured in modern expressive type systems, as found for example in Haskell, and moreover, generative type-driven programming can use that static type information constructively to automatically induce the appropriate liftings. We show also that the structure of multi-dimensional data is inherently a matter of Naperian applicative functors - lax monoidal functors, with strength, commutative up to isomorphism under composition.},
booktitle = {Proceedings of the 1st International Workshop on Type-Driven Development},
pages = {13–14},
numpages = {2},
keywords = {APL, Naperian functor, applicative functor, array, rank polymorphism},
location = {Nara, Japan},
series = {TyDe 2016}
}

@inproceedings{10.1145/292540.292560,
author = {Xi, Hongwei and Pfenning, Frank},
title = {Dependent types in practical programming},
year = {1999},
isbn = {1581130953},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/292540.292560},
doi = {10.1145/292540.292560},
abstract = {We present an approach to enriching the type system of ML with a restricted form of dependent types, where type index objects are drawn from a constraint domain C, leading to the DML(C) language schema. This allows specification and inference of significantly more precise type information, facilitating program error detection and compiler optimization. A major complication resulting from introducing dependent types is that pure type inference for the enriched system is no longer possible, but we show that type-checking a sufficiently annotated program in DML(C) can be reduced to constraint satisfaction in the constraint domain C. We exhibit the unobtrusiveness of our approach through practical examples and prove that DML(C) is conservative over ML. The main contribution of the paper lies in our language design, including the formulation of type-checking rules which makes the approach practical. To our knowledge, no previous type system for a general purpose programming language such as ML has combined dependent types with features including datatype declarations, higher-order functions, general recursions, let-polymorphism, mutable references, and exceptions. In addition, we have finished a prototype implementation of DML(C) for an integer constraint domain C, where constraints are linear inequalities (Xi and Pfenning 1998).},
booktitle = {Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {214–227},
numpages = {14},
location = {San Antonio, Texas, USA},
series = {POPL '99}
}

@inproceedings{thiemann2013agda,
  title={Agda meets {Accelerate}},
  author={Thiemann, Peter and Chakravarty, Manuel MT},
  booktitle={Implementation and Application of Functional Languages: 24th International Symposium, IFL 2012, Oxford, UK, August 30-September 1, 2012, Revised Selected Papers 24},
  pages={174--189},
  year={2013},
  organization={Springer}
}

@inproceedings{10.1145/1926354.1926358,
author = {Chakravarty, Manuel M.T. and Keller, Gabriele and Lee, Sean and McDonell, Trevor L. and Grover, Vinod},
title = {Accelerating {Haskell} array codes with multicore {GPU}s},
year = {2011},
isbn = {9781450304863},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1926354.1926358},
doi = {10.1145/1926354.1926358},
abstract = {Current GPUs are massively parallel multicore processors optimised for workloads with a large degree of SIMD parallelism. Good performance requires highly idiomatic programs, whose development is work intensive and requires expert knowledge.To raise the level of abstraction, we propose a domain-specific high-level language of array computations that captures appropriate idioms in the form of collective array operations. We embed this purely functional array language in Haskell with an online code generator for NVIDIA's CUDA GPGPU programming environment. We regard the embedded language's collective array operations as algorithmic skeletons; our code generator instantiates CUDA implementations of those skeletons to execute embedded array programs.This paper outlines our embedding in Haskell, details the design and implementation of the dynamic code generator, and reports on initial benchmark results. These results suggest that we can compete with moderately optimised native CUDA code, while enabling much simpler source programs.},
booktitle = {Proceedings of the Sixth Workshop on Declarative Aspects of Multicore Programming},
pages = {3–14},
numpages = {12},
keywords = {skeletons, haskell, gpgpu, dynamic compilation, data parallelism, arrays},
location = {Austin, Texas, USA},
series = {DAMP '11}
}

@article{radul2023you,
  title={You only linearize once: Tangents transpose to gradients},
  author={Radul, Alexey and Paszke, Adam and Frostig, Roy and Johnson, Matthew J and Maclaurin, Dougal},
  journal={Proceedings of the ACM on Programming Languages},
  volume={7},
  number={POPL},
  pages={1246--1274},
  year={2023},
  publisher={ACM New York, NY, USA}
}

@article{10.1145/3591268,
author = {Kovach, Scott and Kolichala, Praneeth and Gu, Tiancheng and Kjolstad, Fredrik},
title = {Indexed Streams: A Formal Intermediate Representation for Fused Contraction Programs},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {PLDI},
url = {https://doi.org/10.1145/3591268},
doi = {10.1145/3591268},
abstract = {We introduce indexed streams, a formal operational model and intermediate representation that describes the fused execution of a contraction language that encompasses both sparse tensor algebra and relational algebra. We prove that the indexed stream model is correct with respect to a functional semantics. We also develop a compiler for contraction expressions that uses indexed streams as an intermediate representation. The compiler is only 540 lines of code, but we show that its performance can match both the TACO compiler for sparse tensor algebra and the SQLite and DuckDB query processing libraries for relational algebra.},
journal = {Proc. ACM Program. Lang.},
month = jun,
articleno = {154},
numpages = {25},
keywords = {contractions, functional programming, operational semantics, streams}
}
                  
@inproceedings{10.1145/1863543.1863582,
author = {Keller, Gabriele and Chakravarty, Manuel M.T. and Leshchinskiy, Roman and Peyton Jones, Simon and Lippmeier, Ben},
title = {Regular, shape-polymorphic, parallel arrays in Haskell},
year = {2010},
isbn = {9781605587943},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863543.1863582},
doi = {10.1145/1863543.1863582},
abstract = {We present a novel approach to regular, multi-dimensional arrays in Haskell. The main highlights of our approach are that it (1) is purely functional, (2) supports reuse through shape polymorphism, (3) avoids unnecessary intermediate structures rather than relying on subsequent loop fusion, and (4) supports transparent parallelisation.We show how to embed two forms of shape polymorphism into Haskell's type system using type classes and type families. In particular, we discuss the generalisation of regular array transformations to arrays of higher rank, and introduce a type-safe specification of array slices.We discuss the runtime performance of our approach for three standard array algorithms. We achieve absolute performance comparable to handwritten C code. At the same time, our implementation scales well up to 8 processor cores.},
booktitle = {Proceedings of the 15th ACM SIGPLAN International Conference on Functional Programming},
pages = {261–272},
numpages = {12},
keywords = {arrays, data parallelism, haskell},
location = {Baltimore, Maryland, USA},
series = {ICFP '10}
}

@article{10.1145/1932681.1863582,
author = {Keller, Gabriele and Chakravarty, Manuel M.T. and Leshchinskiy, Roman and Peyton Jones, Simon and Lippmeier, Ben},
title = {Regular, shape-polymorphic, parallel arrays in Haskell},
year = {2010},
issue_date = {September 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1932681.1863582},
doi = {10.1145/1932681.1863582},
abstract = {We present a novel approach to regular, multi-dimensional arrays in Haskell. The main highlights of our approach are that it (1) is purely functional, (2) supports reuse through shape polymorphism, (3) avoids unnecessary intermediate structures rather than relying on subsequent loop fusion, and (4) supports transparent parallelisation.We show how to embed two forms of shape polymorphism into Haskell's type system using type classes and type families. In particular, we discuss the generalisation of regular array transformations to arrays of higher rank, and introduce a type-safe specification of array slices.We discuss the runtime performance of our approach for three standard array algorithms. We achieve absolute performance comparable to handwritten C code. At the same time, our implementation scales well up to 8 processor cores.},
journal = {SIGPLAN Not.},
month = sep,
pages = {261–272},
numpages = {12},
keywords = {arrays, data parallelism, haskell}
}

@article{10.1145/3473593,
author = {Paszke, Adam and Johnson, Daniel D. and Duvenaud, David and Vytiniotis, Dimitrios and Radul, Alexey and Johnson, Matthew J. and Ragan-Kelley, Jonathan and Maclaurin, Dougal},
title = {Getting to the point: index sets and parallelism-preserving autodiff for pointful array programming},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473593},
doi = {10.1145/3473593},
abstract = {We present a novel programming language design that attempts to combine the clarity and safety of high-level functional languages with the efficiency and parallelism of low-level numerical languages. We treat arrays as eagerly-memoized functions on typed index sets, allowing abstract function manipulations, such as currying, to work on arrays. In contrast to composing primitive bulk-array operations, we argue for an explicit nested indexing style that mirrors application of functions to arguments. We also introduce a fine-grained typed effects system which affords concise and automatically-parallelized in-place updates. Specifically, an associative accumulation effect allows reverse-mode automatic differentiation of in-place updates in a way that preserves parallelism. Empirically, we benchmark against the Futhark array programming language, and demonstrate that aggressive inlining and type-driven compilation allows array programs to be written in an expressive, "pointful" style with little performance penalty.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {88},
numpages = {29},
keywords = {parallel computing, automatic differentiation, Array programming}
}

@article{10.1145/3632878,
author = {Smeding, Tom J. and V\'{a}k\'{a}r, Matthijs I. L.},
title = {Efficient CHAD},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632878},
doi = {10.1145/3632878},
abstract = {We show how the basic Combinatory Homomorphic Automatic Differentiation (CHAD) algorithm can be optimised, using well-known methods, to yield a simple, composable, and generally applicable reverse-mode automatic differentiation (AD) technique that has the correct computational complexity that we would expect of reverse-mode AD. Specifically, we show that the standard optimisations of sparse vectors and state-passing style code (as well as defunctionalisation/closure conversion, for higher-order languages) give us a purely functional algorithm that is most of the way to the correct complexity, with (functional) mutable updates taking care of the final log-factors. We provide an Agda formalisation of our complexity proof. Finally, we discuss how the techniques apply to differentiating parallel functional array programs: the key observations are 1) that all required mutability is (commutative, associative) accumulation, which lets us preserve task-parallelism and 2) that we can write down data-parallel derivatives for most data-parallel array primitives.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {36},
numpages = {29},
keywords = {automatic differentiation, functional programming, source transformation}
}

@inproceedings{cont1,
author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil},
title = {Categories of containers},
year = {2003},
isbn = {3540008977},
booktitle = {Proceedings of the 6th International Conference on Foundations of Software Science and Computation Structures and Joint European Conference on Theory and Practice of Software},
pages = {23–38},
numpages = {16},
location = {Warsaw, Poland},
series = {FOSSACS'03/ETAPS'03}
}

@article{cont2,
title = {Containers: Constructing strictly positive types},
journal = {Theoretical Computer Science},
volume = {342},
number = {1},
pages = {3-27},
year = {2005},
note = {Applied Semantics: Selected Topics},
issn = {0304-3975},
doi = {https://doi.org/10.1016/j.tcs.2005.06.002},
url = {https://www.sciencedirect.com/science/article/pii/S0304397505003373},
author = {Michael Abbott and Thorsten Altenkirch and Neil Ghani},
keywords = {Type theory, Category theory, Container functors, W-Types, Induction, Coinduction, Initial algebras, Final coalgebras},
abstract = {We introduce the notion of a Martin-Löf category—a locally cartesian closed category with disjoint coproducts and initial algebras of container functors (the categorical analogue of W-types)—and then establish that nested strictly positive inductive and coinductive types, which we call strictly positive types, exist in any Martin-Löf category. Central to our development are the notions of containers and container functors. These provide a new conceptual analysis of data structures and polymorphic functions by exploiting dependent type theory as a convenient way to define constructions in Martin-Löf categories. We also show that morphisms between containers can be full and faithfully interpreted as polymorphic functions (i.e.natural transformations) and that, in the presence of W-types, all strictly positive types (including nested inductive and coinductive types) give rise to containers.}
}
  
@inproceedings{intrinsic1,
author = {Altenkirch, Thorsten and Reus, Bernhard},
title = {Monadic Presentations of Lambda Terms Using Generalized Inductive Types},
year = {1999},
isbn = {3540665366},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {We present a definition of untyped λ-terms using a heterogeneous datatype, i.e. an inductively defined operator. This operator can be extended to a Kleisli triple, which is a concise way to verify the substitution laws for λ-calculus. We also observe that repetitions in the definition of the monad as well as in the proofs can be avoided by using well-founded recursion and induction instead of structural induction. We extend the construction to the simply typed λ-calculus using dependent types, and show that this is an instance of a generalization of Kleisli triples. The proofs for the untyped case have been checked using the LEGO system.},
booktitle = {Proceedings of the 13th International Workshop and 8th Annual Conference of the EACSL on Computer Science Logic},
pages = {453–468},
numpages = {16},
series = {CSL '99}
}

  
@article{intrinsic2,
author = {Allais, Guillaume and Atkey, Robert and Chapman, James and McBride, Conor and McKinna, James},
title = {A type and scope safe universe of syntaxes with binding: their semantics and proofs},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {ICFP},
url = {https://doi.org/10.1145/3236785},
doi = {10.1145/3236785},
abstract = {Almost every programming language’s syntax includes a notion of binder and corresponding bound occurrences, along with the accompanying notions of α-equivalence, capture avoiding substitution, typing contexts, runtime environments, and so on. In the past, implementing and reasoning about programming languages required careful handling to maintain the correct behaviour of bound variables. Modern programming languages include features that enable constraints like scope safety to be expressed in types. Nevertheless, the programmer is still forced to write the same boilerplate over again for each new implementation of a scope safe operation (e.g., renaming, substitution, desugaring, printing, etc.), and then again for correctness proofs. We present an expressive universe of syntaxes with binding and demonstrate how to (1) implement scope safe traversals once and for all by generic programming; and (2) how to derive properties of these traversals by generic proving. Our universe description, generic traversals and proofs, and our examples have all been formalised in Agda and are available in the accompanying material. NB. we recommend printing the paper in colour to benefit from syntax highlighting in code fragments.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {90},
numpages = {30},
keywords = {Agda, Fusion, Generic Programming, Logical Relations, Semantics, Simulation, Syntax with Binding}
}

@inproceedings{intrinsic3,
author = {Allais, Guillaume and Chapman, James and McBride, Conor and McKinna, James},
title = {Type-and-scope safe programs and their proofs},
year = {2017},
isbn = {9781450347051},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3018610.3018613},
doi = {10.1145/3018610.3018613},
abstract = {We abstract the common type-and-scope safe structure from computations on λ-terms that deliver, e.g., renaming, substitution, evaluation, CPS-transformation, and printing with a name supply. By exposing this structure, we can prove generic simulation and fusion lemmas relating operations built this way. This work has been fully formalised in Agda.},
booktitle = {Proceedings of the 6th ACM SIGPLAN Conference on Certified Programs and Proofs},
pages = {195–207},
numpages = {13},
keywords = {Agda, Generic Programming, Lambda-calculus, Mechanized Meta-Theory, Normalisation by Evaluation, Semantics},
location = {Paris, France},
series = {CPP 2017}
}

  
@InProceedings{ope-cat,
author="Altenkirch, Thorsten
and Hofmann, Martin
and Streicher, Thomas",
editor="Pitt, David
and Rydeheard, David E.
and Johnstone, Peter",
title="Categorical reconstruction of a reduction free normalization proof",
booktitle="Category Theory and Computer Science",
year="1995",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="182--199",
isbn="978-3-540-44661-3"
}




