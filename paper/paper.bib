@INPROCEEDINGS{MDH,
  author={Rasch, Ari and Schulze, Richard and Gorlatch, Sergei},
  booktitle={2019 28th International Conference on Parallel Architectures and Compilation Techniques (PACT)},
  title={Generating Portable High-Performance Code via Multi-Dimensional Homomorphisms},
  year={2019},
  volume={},
  number={},
  pages={354-369},
  numpages={16},
  doi={10.1109/PACT.2019.00035}}


@article{BLIS,
   author      = {Field G. {V}an~{Z}ee and Robert A. {v}an~{d}e~{G}eijn},
   title       = {{BLIS}: A Framework for Rapidly Instantiating {BLAS} Functionality},
   journal     = {ACM Transactions on Mathematical Software},
   volume      = {41},
   number      = {3},
   pages       = {14:1--14:33},
   numpages       = {33},
   month       = {June},
   year        = {2015},
   issue_date  = {June 2015},
   url         = {https://doi.acm.org/10.1145/2764454},
}

@article{goto,
    author = {Goto, Kazushige and Geijn, Robert A. van de},
    title = {{A}natomy of {H}igh-{P}erformance {M}atrix {M}ultiplication},
    year = {2008},
    issue_date = {May 2008},
    publisher = {Association for {C}omputing {M}achinery},
    address = {New York, NY, USA},
    volume = {34},
    number = {3},
    issn = {0098-3500},
    url = {https://doi.org/10.1145/1356052.1356053},
    doi = {10.1145/1356052.1356053},
    journal = {ACM Trans. Math. Softw.},
    month = {may},
    articleno = {12},
    numpages = {25},
    keywords = {basic linear algebra subprograms, matrix multiplication, Linear algebra}
}

@INPROCEEDINGS{OpenBLAS,
  author={{W}ang, {Q}ian and {Z}hang, {X}ianyi and {Z}hang, {Y}unquan and {Y}i, {Q}ing},
  booktitle={SC '13: Proceedings of the International Conference on High Performance Computing,
      {N}etworking, Storage and Analysis},
  title={{AUGEM}: {A}utomatically generate high performance {D}ense {L}inear {A}lgebra kernels on
      x86 {CPU}s},
  year={2013},
  volume={},
  number={},
  pages={1-12},
  numpages={12},
  doi={10.1145/2503210.2503219}
}

@misc{paper-src,
    author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo and Koopman, Thomas},
    title = {Sources of {R}ank-{P}olymorphism for {S}hape-{G}uided {B}locking},
    howpublished = {\url{https://gitlab.sac-home.org/sac-group/2023-array}},
    year = {2023}
}

@article{Strassen,
    author = {Strassen, V.},
    journal = {Numerische Mathematik},
    keywords = {numerical analysis},
    pages = {354-356},
    numpages = {3},
    title = {Gaussian Elimination is not Optimal.},
    url = {http://eudml.org/doc/131927},
    volume = {13},
    year = {1969},
}

@INPROCEEDINGS{StrassenReloaded,
  author={Huang, Jianyu and Smith, Tyler M. and Henry, Greg M. and Van De Geijn, Robert A.},
  booktitle={SC '16: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
  title={Strassen's Algorithm Reloaded},
  year={2016},
  volume={},
  number={},
  pages={690-701},
  numpages={12},
  doi={10.1109/SC.2016.58}
}

@inbook{laserMatrix,
    author = {Josh Alman and Virginia Vassilevska Williams},
    title = {A Refined Laser Method and Faster Matrix Multiplication},
    booktitle = {Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms (SODA)},
    chapter = {},
    pages = {522-539},
    numpages = {28},
    year = {2020},
    doi = {10.1137/1.9781611976465.32},
    URL = {https://epubs.siam.org/doi/abs/10.1137/1.9781611976465.32},
    eprint = {https://epubs.siam.org/doi/pdf/10.1137/1.9781611976465.32},
}

@article{BLAS,
  title={An updated set of basic linear algebra subprograms (BLAS)},
  author={Blackford, L Susan and Petitet, Antoine and Pozo, Roldan and Remington, Karin and Whaley, R Clint and Demmel, James and Dongarra, Jack and Duff, Iain and Hammarling, Sven and Henry, Greg and others},
  journal={ACM Transactions on Mathematical Software},
  volume={28},
  number={2},
  pages={135--151},
  numpages={17},
  year={2002}
}

@article{Morton,
    author = {Morton, Guy},
    year = {1966},
    month = {01},
    pages = {},
    title = {A Computer Oriented Geodetic Data Base and a New Technique in File Sequencing}
}

@article{roofline,
    author = {Williams, Samuel and Waterman, Andrew and Patterson, David},
    title = {Roofline: An Insightful Visual Performance Model for Multicore Architectures},
    year = {2009},
    issue_date = {April 2009},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {52},
    number = {4},
    issn = {0001-0782},
    url = {https://doi.org/10.1145/1498765.1498785},
    doi = {10.1145/1498765.1498785},
    abstract = {The Roofline model offers insight on how to improve the performance of software and hardware.},
    journal = {Commun. ACM},
    month = {apr},
    pages = {65–76},
    numpages = {12}
}

@inproceedings{10.1145/567067.567085,
author = {Allen, J. R. and Kennedy, Ken and Porterfield, Carrie and Warren, Joe},
title = {Conversion of Control Dependence to Data Dependence},
year = {1983},
isbn = {0897910907},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/567067.567085},
doi = {10.1145/567067.567085},
abstract = {Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University.},
booktitle = {Proceedings of the 10th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages},
pages = {177–189},
numpages = {13},
location = {Austin, Texas},
series = {POPL '83}
}

@article{10.1145/3235029,
author = {Gareev, Roman and Grosser, Tobias and Kruse, Michael},
title = {High-Performance Generalized Tensor Operations: A Compiler-Oriented Approach},
year = {2018},
issue_date = {September 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {3},
issn = {1544-3566},
url = {https://doi.org/10.1145/3235029},
doi = {10.1145/3235029},
abstract = {The efficiency of tensor contraction is of great importance. Compilers cannot optimize it well enough to come close to the performance of expert-tuned implementations. All existing approaches that provide competitive performance require optimized external code. We introduce a compiler optimization that reaches the performance of optimized BLAS libraries without the need for an external implementation or automatic tuning. Our approach provides competitive performance across hardware architectures and can be generalized to deliver the same benefits for algebraic path problems. By making fast linear algebra kernels available to everyone, we expect productivity increases when optimized libraries are not available.},
journal = {ACM Trans. Archit. Code Optim.},
month = {sep},
articleno = {34},
numpages = {27},
keywords = {matrix-matrix multiplication, Tensor contractions, high-performance computing}
}


@article{10.1145/3570641,
author = {Tollenaere, Nicolas and Iooss, Guillaume and Pouget, St\'{e}phane and Brunie, Hugo and Guillon, Christophe and Cohen, Albert and Sadayappan, P. and Rastello, Fabrice},
title = {Autotuning Convolutions Is Easier Than You Think},
year = {2023},
issue_date = {June 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {20},
number = {2},
issn = {1544-3566},
url = {https://doi.org/10.1145/3570641},
doi = {10.1145/3570641},
abstract = {A wide range of scientific and machine learning applications depend on highly optimized implementations of tensor computations. Exploiting the full capacity of a given processor architecture remains a challenging task, due to the complexity of the microarchitectural features that come into play when seeking near-peak performance. Among the state-of-the-art techniques for loop transformations for performance optimization, AutoScheduler [Zheng et al. 2020a] tends to outperform other systems. It often yields higher performance as compared to vendor libraries, but takes a large number of runs to converge, while also involving a complex training environment. In this article, we define a structured configuration space that enables much faster convergence to high-performance code versions, using only random sampling of candidates. We focus on two-dimensional convolutions on CPUs. Compared to state-of-the-art libraries, our structured search space enables higher performance for typical tensor shapes encountered in convolution stages in deep learning pipelines. Compared to auto-tuning code generators like AutoScheduler, it prunes the search space while increasing the density of efficient implementations. We analyze the impact on convergence speed and performance distribution, on two Intel x86 processors and one ARM AArch64 processor. We match or outperform the performance of the state-of-the-art oneDNN library and TVM’s AutoScheduler, while reducing the autotuning effort by at least an order of magnitude.},
journal = {ACM Trans. Archit. Code Optim.},
month = {mar},
articleno = {20},
numpages = {24},
keywords = {optimisation space, microkernel, convolution, Code generation}
}

@article{CLINTWHALEY20013,
title = {Automated empirical optimizations of software and the ATLAS project},
journal = {Parallel Computing},
volume = {27},
number = {1},
pages = {3-35},
numpages = {33},
year = {2001},
note = {New Trends in High Performance Computing},
issn = {0167-8191},
doi = {https://doi.org/10.1016/S0167-8191(00)00087-9},
url = {https://www.sciencedirect.com/science/article/pii/S0167819100000879},
author = {R. {Clint Whaley} and Antoine Petitet and Jack J. Dongarra},
keywords = {ATLAS, BLAS, Portable performance, AEOS},
}


@inproceedings {Ansor,
author = {Lianmin Zheng and Chengfan Jia and Minmin Sun and Zhao Wu and Cody Hao Yu and Ameer Haj-Ali and Yida Wang and Jun Yang and Danyang Zhuo and Koushik Sen and Joseph E. Gonzalez and Ion Stoica},
title = {Ansor: Generating {High-Performance} Tensor Programs for Deep Learning},
booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
year = {2020},
isbn = {978-1-939133-19-9},
pages = {863--879},
numpages = {17},
url = {https://www.usenix.org/conference/osdi20/presentation/zheng},
publisher = {USENIX Association},
month = nov,
}

@article{10.1145/2858949.2784754,
author = {Steuwer, Michel and Fensch, Christian and Lindley, Sam and Dubach, Christophe},
title = {Generating Performance Portable Code Using Rewrite Rules: From High-Level Functional Expressions to High-Performance OpenCL Code},
year = {2015},
issue_date = {September 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/2858949.2784754},
doi = {10.1145/2858949.2784754},
journal = {SIGPLAN Not.},
month = {aug},
pages = {205–217},
numpages = {13},
keywords = {OpenCL, GPU, performance portability, code generation, Algorithmic patterns, rewrite rules}
}



@inproceedings{10.1145/2784731.2784754,
author = {Steuwer, Michel and Fensch, Christian and Lindley, Sam and Dubach, Christophe},
title = {Generating Performance Portable Code Using Rewrite Rules: From High-Level Functional Expressions to High-Performance OpenCL Code},
year = {2015},
isbn = {9781450336697},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2784731.2784754},
doi = {10.1145/2784731.2784754},
booktitle = {Proceedings of the 20th ACM SIGPLAN International Conference on Functional Programming},
pages = {205–217},
numpages = {13},
keywords = {OpenCL, Algorithmic patterns, code generation, GPU, performance portability, rewrite rules},
location = {Vancouver, BC, Canada},
series = {ICFP 2015}
}


@article{10.1145/3150211,
author = {Ragan-Kelley, Jonathan and Adams, Andrew and Sharlet, Dillon and Barnes, Connelly and Paris, Sylvain and Levoy, Marc and Amarasinghe, Saman and Durand, Fr\'{e}do},
title = {Halide: Decoupling Algorithms from Schedules for High-Performance Image Processing},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {61},
number = {1},
issn = {0001-0782},
url = {https://doi.org/10.1145/3150211},
doi = {10.1145/3150211},
journal = {Commun. ACM},
month = {dec},
pages = {106–115},
numpages = {10}
}

@article{Flame,
author = {Zee, Field G. Van and Bientinesi, Paolo and Low, Tze Meng and Geijn, Robert A. van de},
title = {Scalable Parallelization of FLAME Code via the Workqueuing Model},
year = {2008},
issue_date = {March 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {34},
number = {2},
issn = {0098-3500},
url = {https://doi.org/10.1145/1326548.1326552},
doi = {10.1145/1326548.1326552},
journal = {ACM Trans. Math. Softw.},
month = {mar},
articleno = {10},
numpages = {29},
keywords = {parallel, FLAME, SMP, scalability, workqueuing, OpenMP}
}

@article{10.1145/2925987,
author = {Low, Tze Meng and Igual, Francisco D. and Smith, Tyler M. and Quintana-Orti, Enrique S.},
title = {Analytical Modeling Is Enough for High-Performance BLIS},
year = {2016},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {43},
number = {2},
issn = {0098-3500},
url = {https://doi.org/10.1145/2925987},
doi = {10.1145/2925987},
journal = {ACM Trans. Math. Softw.},
month = {aug},
articleno = {12},
numpages = {18},
keywords = {matrix multiplication, high performance, Linear algebra, libraries, analytical modeling}
}


@article{10.1145/362875.362879,
author = {McKellar, A. C. and Coffman, E. G.},
title = {Organizing Matrices and Matrix Operations for Paged Memory Systems},
year = {1969},
issue_date = {March 1969},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {3},
issn = {0001-0782},
url = {https://doi.org/10.1145/362875.362879},
doi = {10.1145/362875.362879},
journal = {Commun. ACM},
month = {mar},
pages = {153–165},
numpages = {13},
keywords = {virtual memory systems, paged memory systems, storage allocation, paging algorithms, array processing, array storage allocation, matrix algorithms}
}

@article{10.1145/106973.106981,
author = {Lam, Monica D. and Rothberg, Edward E. and Wolf, Michael E.},
title = {The Cache Performance and Optimizations of Blocked Algorithms},
year = {1991},
issue_date = {Apr. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {26},
number = {4},
issn = {0362-1340},
url = {https://doi.org/10.1145/106973.106981},
doi = {10.1145/106973.106981},
journal = {SIGPLAN Not.},
month = {apr},
pages = {63–74},
numpages = {12}
}



@inproceedings{10.1145/106972.106981,
author = {Lam, Monica D. and Rothberg, Edward E. and Wolf, Michael E.},
title = {The Cache Performance and Optimizations of Blocked Algorithms},
year = {1991},
isbn = {0897913809},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/106972.106981},
doi = {10.1145/106972.106981},
booktitle = {Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {63–74},
numpages = {12},
location = {Santa Clara, California, USA},
series = {ASPLOS IV}
}


@inproceedings{10.1145/258915.258946,
author = {Kodukula, Induprakas and Ahmed, Nawaaz and Pingali, Keshav},
title = {Data-Centric Multi-Level Blocking},
year = {1997},
isbn = {0897919076},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/258915.258946},
doi = {10.1145/258915.258946},
booktitle = {Proceedings of the ACM SIGPLAN 1997 Conference on Programming Language Design and Implementation},
pages = {346–357},
numpages = {12},
location = {Las Vegas, Nevada, USA},
series = {PLDI '97}
}

@article{10.1145/3110251,
    author = {Elliott, Conal},
    title = {Generic Functional Parallel Algorithms: Scan and FFT},
    year = {2017},
    issue_date = {September 2017},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {1},
    number = {ICFP},
    url = {https://doi.org/10.1145/3110251},
    doi = {10.1145/3110251},
    journal = {Proc. ACM Program. Lang.},
    month = {aug},
    articleno = {7},
    numpages = {25},
    keywords = {fast Fourier transform, parallel prefix computation, generic programming}
}

@InProceedings{10.1007/978-3-642-24452-0_6,
author="Trojahner, Kai
and Grelck, Clemens",
editor="Scholz, Sven-Bodo
and Chitil, Olaf",
title="Descriptor-Free Representation of Arrays with Dependent Types",
booktitle="Implementation and Application of Functional Languages",
year="2011",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="100--117",
numpages={18},
isbn="978-3-642-24452-0"
}

@inproceedings{10.1145/277650.277732,
author = {Xi, Hongwei and Pfenning, Frank},
title = {Eliminating Array Bound Checking through Dependent Types},
year = {1998},
isbn = {0897919874},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/277650.277732},
doi = {10.1145/277650.277732},
booktitle = {Proceedings of the ACM SIGPLAN 1998 Conference on Programming Language Design and Implementation},
pages = {249–257},
numpages = {9},
location = {Montreal, Quebec, Canada},
series = {PLDI '98}
}

@InProceedings{10.1007/978-3-642-54833-8_3,
author="Slepak, Justin
and Shivers, Olin
and Manolios, Panagiotis",
editor="Shao, Zhong",
title="An Array-Oriented Language with Static Rank Polymorphism",
booktitle="Programming Languages and Systems",
year="2014",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="27--46",
numpages={20},
isbn="978-3-642-54833-8"
}

@inproceedings{10.1145/3460944.3464310,
author = {Henriksen, Troels and Elsman, Martin},
title = {Towards Size-Dependent Types for Array Programming},
year = {2021},
isbn = {9781450384667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3460944.3464310},
doi = {10.1145/3460944.3464310},
abstract = {We present a type system for expressing size constraints on array types in an ML-style type system. The goal is to detect shape mismatches at compile-time, while being simpler than full dependent types. The main restrictions is that the only terms that can occur in types are array sizes, and syntactically they must be variables or constants. For those programs where this is not sufficient, we support a form of existential types, with the type system automatically managing the requisite book-keeping. We formalise a large subset of the type system in a small core language, which we prove sound. We also present an integration of the type system in the high-performance parallel functional language Futhark, and show on a collection of 44 representative programs that the restrictions in the type system are not too problematic in practice.},
booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
pages = {1–14},
numpages = {14},
keywords = {parallel programming, type systems, functional programming},
location = {Virtual, Canada},
series = {ARRAY 2021}
}


@inproceedings{2020-msfp,
  author    = {Artjoms {\v{S}}inkarovs},
  editor    = {Max S. New and
               Sam Lindley},
  title     = {Multi-dimensional Arrays with Levels},
  booktitle = {Proceedings Eighth Workshop on Mathematically Structured Functional
               Programming, MSFP@ETAPS 2020, Dublin, Ireland, 25th April 2020},
  series    = {{EPTCS}},
  volume    = {317},
  pages     = {57--71},
  numpages  = {15},
  year      = {2020},
  url       = {https://doi.org/10.4204/EPTCS.317.4},
  doi       = {10.4204/EPTCS.317.4},
  timestamp = {Fri, 08 May 2020 16:00:57 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2005-00198.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{abs-2105-10819,
  author       = {Artjoms Sinkarovs and
                  Jesper Cockx},
  title        = {Choosing is Losing: How to combine the benefits of shallow and deep
                  embeddings through reflection},
  journal      = {CoRR},
  volume       = {abs/2105.10819},
  year         = {2021},
  url          = {https://arxiv.org/abs/2105.10819},
  eprinttype    = {arXiv},
  eprint       = {2105.10819},
  timestamp    = {Mon, 31 May 2021 16:16:57 +0200},
  biburl       = {https://dblp.org/rec/journals/corr/abs-2105-10819.bib},
  bibsource    = {dblp computer science bibliography, https://dblp.org}
}


@inproceedings{10.1145/3520306.3534500,
    author = {\v{S}inkarovs, Artjoms and Scholz, Sven-Bodo},
    title = {Parallel Scan as a Multidimensional Array Problem},
    year = {2022},
    isbn = {9781450392693},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3520306.3534500},
    doi = {10.1145/3520306.3534500},
    abstract = {For many algorithms, it is challenging to identify a suitable parallel version, as the design space is typically very large. In this paper we demonstrate how rank-polymorphic array languages can be used as a tool to explore such design spaces through concise high-level specifications. If input data can be organised into a multi-dimensional array, and the algorithm can be stated as a recursive traversal over sub-arrays, array languages offer a lot of expressive power. The reason for this is that array shapes can be used to guide recursive traversals. Conciseness of specifications comes from array reshapes that move the desired elements into canonical hyperplanes. As a case study, we discuss several variants of implementing prefix sums (also known as scans) in SaC. We demonstrate how small code adjustments suffice to change the concurrency pattern exposed to the compiler. It turns out that variability that is typically achieved by generic inductive data types such as binary trees is a special case of what is offered by the array paradigm.},
    booktitle = {Proceedings of the 8th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
    pages = {1–11},
    numpages = {11},
    keywords = {functional programming, rank polymorphism, algorithms, array languages, parallelism, prefix sum},
    location = {San Diego, CA, USA},
    series = {ARRAY 2022}
}

@INPROCEEDINGS{polyhedral,
  author={Pouchet, Louis-Noel and Bastoul, Cedric and Cohen, Albert and Vasilache, Nicolas},
  booktitle={International Symposium on Code Generation and Optimization (CGO'07)},
  title={Iterative Optimization in the Polyhedral Model: Part I, One-Dimensional Time},
  year={2007},
  volume={},
  number={},
  pages={144-156},
  numpages={13},
  abstract={Emerging microprocessors offer unprecedented parallel computing capabilities and deeper memory hierarchies, increasing the importance of loop transformations in optimizing compilers. Because compiler heuristics rely on simplistic performance models, and because they are bound to a limited set of transformations sequences, they only uncover a fraction of the peak performance on typical benchmarks. Iterative optimization is a maturing framework to address these limitations, but so far, it was not successfully applied complex loop transformation sequences because of the combinatorics of the optimization search space. We focus on the class of loop transformation which can be expressed as one-dimensional affine schedules. We define a systematic exploration method to enumerate the space of all legal, distinct transformations in this class. This method is based on an upstream characterization, as opposed to state-of-the-art downstream filtering approaches. Our results demonstrate orders of magnitude improvements in the size of the search space and in the convergence speed of a dedicated iterative optimization heuristic},
  keywords={},
  doi={10.1109/CGO.2007.21},
  ISSN={},
  month={March},
}

@misc{gratzer2022controlling,
      title={Controlling unfolding in type theory},
      author={Daniel Gratzer and Jonathan Sterling and Carlo Angiuli and Thierry Coquand and Lars Birkedal},
      year={2022},
      eprint={2210.05420},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}

@misc{gccExtension,
    author= {{GNU Project}},
    title = {{U}sing {V}ector {I}nstructions through {B}uilt-in {F}unctions},
    note  = {\url{https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html},
             Last accessed on 2023-05-30},
}

@InProceedings{withFolding,
  author     = {Sven-Bodo Scholz},
  title      = {With-loop-folding in Sac --- Condensing Consecutive Array Operations},
  booktitle  = {Implementation of Functional Languages, 9th International Workshop (IFL'97), St. Andrews, UK, Selected Papers},
  year       = {1998},
  editor     = {Chris Clack and Tony Davie and Kevin Hammond},
  volume     = {1467},
  series     = {Lecture Notes in Computer Science},
  pages      = {72--92},
  numpages   = {21},
  publisher  = {Springer},
  category   = {core,design,opt},
  doi        = {10.1007/BFb0055425},
  isbn       = {978-3-540-64849-9},
  pubaddress = {Berlin, Heidelberg, Germany},
  topics     = {SAC,Avoiding Temporaries,Implementation of Arrays},
  url        = {wlf-st-andrews-97.pdf},
}

@inproceedings{cpcgcc,
  Author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo},
  Title = {Portable Support for Explicit Vectorisation in C},
  BookTitle = {16th Workshop on Compilers for Parallel
  Computing (CPC'12)},
  Year = {2012}
}

@inproceedings{10.1145/3412932.3412947,
author = {Scholz, Sven-Bodo and \v{S}inkarovs, Artjoms},
title = {Tensor Comprehensions in SaC},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412947},
doi = {10.1145/3412932.3412947},
abstract = {We propose a new notation for data parallel operators on multi-dimensional arrays named tensor comprehensions. This notation combines the basic principle of array-comprehensions with syntactical shortcuts very close to those found in the so-called Tensor Notations used in Physics and Mathematics. As a result, complex operators with rich semantics can be defined concisely. The key to this conciseness lies in the ability to define shape-polymorphic operations combined with the ability to infer array shapes from the immediate context. The paper provides a definition of the proposed notation, a formal shape inference process, as well as a set of re-write rules that translates tensor comprehensions as a zero-cost syntactic sugar into standard SaC expressions.},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {15},
numpages = {13},
location = {Singapore, Singapore},
series = {IFL '19}
}

@misc{MKL,
    author= {{Intel}},
    title = {{I}ntel one{API} {M}ath {K}ernel {L}ibrary},
    note  = {\url{https://www.intel.com/content/www/us/en/developer/tools/oneapi/onemkl.html},
             Last accessed on 2023-05-31},
}

@INPROCEEDINGS{sequoia,
  author={Fatahalian, Kayvon and Knight, Timothy J. and Houston, Mike and Erez, Mattan and Horn, Daniel Reiter and Leem, Larkhoon and Park, Ji Young and Ren, Manman and Aiken, Alex and Dally, William J. and Hanrahan, Pat},

  booktitle={SC '06: Proceedings of the 2006 ACM/IEEE Conference on Supercomputing},

  title={Sequoia: Programming the Memory Hierarchy},

  year={2006},

  volume={},

  number={},

  pages={4-4},

  numpages={1},

  doi={10.1109/SC.2006.55}
}

@misc{artefact,
    author = {{\v{S}}inkarovs, Artjoms and Scholz, Sven-Bodo and Koopman, Thomas},
    title = {Artefact for {R}ank-{P}olymorphism for {S}hape-{G}uided {B}locking},
    DOI = {10.1145/3580402},
    year = {2023}
}

@inproceedings{cnn-array,
author = {\v{S}inkarovs, Artjoms and Vie\ss{}mann, Hans-Nikolai and Scholz, Sven-Bodo},
title = {Array languages make neural networks fast},
year = {2021},
isbn = {9781450384667},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3460944.3464312},
doi = {10.1145/3460944.3464312},
booktitle = {Proceedings of the 7th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming},
pages = {39–50},
numpages = {12},
keywords = {machine learning, array language},
location = {Virtual, Canada},
series = {ARRAY 2021}
}


@article{containers,
title={Indexed containers},
volume={25},
DOI={10.1017/S095679681500009X},
journal={Journal of Functional Programming},
author={Altenkirch, Thorsten and Ghani, Neil and Hancock, Peter and McBride, Conor and Morris, Peter},
year={2015},
pages={e5}
}


@inproceedings{subst,
author = {Keller, Chantal and Altenkirch, Thorsten},
title = {Hereditary substitutions for simple types, formalized},
year = {2010},
isbn = {9781450302555},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1863597.1863601},
doi = {10.1145/1863597.1863601},
booktitle = {Proceedings of the Third ACM SIGPLAN Workshop on Mathematically Structured Functional Programming},
pages = {3–10},
numpages = {8},
keywords = {decidability of Βη-equality, hereditary substitutions, normalizer, type theory},
location = {Baltimore, Maryland, USA},
series = {MSFP '10}
}



@inproceedings{hoas,
  author = {Pfenning, F. and Elliott, C.},
  title = {Higher-order abstract syntax},
  year = {1988},
  isbn = {0897912691},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/53990.54010},
  doi = {10.1145/53990.54010},
  booktitle = {Proceedings of the ACM SIGPLAN 1988 Conference on Programming Language Design and Implementation},
  pages = {199–208},
  numpages = {10},
  location = {Atlanta, Georgia, USA},
  series = {PLDI '88}
}

@article{backprop-stlc,
author = {Brunel, Alo\"{\i}s and Mazza, Damiano and Pagani, Michele},
title = {Backpropagation in the simply typed lambda-calculus with linear negation},
year = {2019},
issue_date = {January 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {POPL},
url = {https://doi.org/10.1145/3371132},
doi = {10.1145/3371132},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {64},
numpages = {27},
keywords = {Differentiable Programming, Lambda-Calculus, Linear Logic}
}


@article{autodiff-survey,
author = {Baydin, At\i{}l\i{}m G\"{u}nes and Pearlmutter, Barak A. and Radul, Alexey Andreyevich and Siskind, Jeffrey Mark},
title = {Automatic differentiation in machine learning: a survey},
year = {2017},
issue_date = {January 2017},
publisher = {JMLR.org},
volume = {18},
number = {1},
issn = {1532-4435},
journal = {J. Mach. Learn. Res.},
month = {jan},
pages = {5595–5637},
numpages = {43},
keywords = {differentiable programming, backpropagation}
}
       
@inproceedings{tensor-comp,
author = {Scholz, Sven-Bodo and \v{S}inkarovs, Artjoms},
title = {Tensor comprehensions in SaC},
year = {2021},
isbn = {9781450375627},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3412932.3412947},
doi = {10.1145/3412932.3412947},
booktitle = {Proceedings of the 31st Symposium on Implementation and Application of Functional Languages},
articleno = {15},
numpages = {13},
location = {Singapore, Singapore},
series = {IFL '19}
}

@article{early-ad1,
author = {Hanson, James W. and Caviness, Jane Shearin and Joseph, Camilla},
title = {Analytic differentiation by computer},
year = {1962},
issue_date = {June 1962},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {6},
issn = {0001-0782},
url = {https://doi.org/10.1145/367766.368195},
doi = {10.1145/367766.368195},
abstract = {During the past few years a major portion of the work in computer applications has been concentrated in the two closely related fields of automatic programming and symbol manipulation. The results of this effort have been a wealth of new computer languages, a better understanding and definition of the basic principles and problems of symbol manipulation, and a growing body of algorithms and techniques for use in the applications.},
journal = {Commun. ACM},
month = {jun},
pages = {349–355},
numpages = {7}
}

@MASTERSTHESIS{early-ad2,
       author = "Nolan, J. F.",
       title = "Analytical Differentiation on a Digital Computer",
       school = "Massachusetts Institute of Technology",
       year = "1953",
       month = "May",
}

@inproceedings {futhark/sc22ad,
author = {R. Schenck and O. RÃ¸nning and T. Henriksen and C. E. Oancea},
booktitle = {2022 SC22: International Conference for High Performance Computing, Networking, Storage and Analysis (SC) (SC)},
title = {AD for an Array Language with Nested Parallelism},
year = {2022},
volume = {},
issn = {2167-4337},
pages = {829-843},
abstract = {We present a technique for applying reverse mode automatic differentiation (AD) on a non-recursive second-order functional array language that supports nested parallelism and is primarily aimed at efficient GPU execution. The key idea is to eliminate the need for a tape by relying on redundant execution to bring into each new scope all program variables that may be needed by the differentiated code. Efficient execution is enabled by the observation that perfectly nested scopes do not introduce re-execution and that such perfect nests can be readily produced by application of known compiler transformations. Our technique differentiates loops and bulk-parallel operatorsâ€”e.g., map, reduce(-by-index), scan, and scatterâ€”by specific rewrite rules and aggressively optimizes the resulting nested-parallel code. We report an evaluation that compares with established AD solutions and demonstrates competitive performance on ten common benchmarks from recent applied AD literature.},
keywords = {automatic differentiation;functional data parallel language;compilers;gpgpu},
doi = {},
url = {https://doi.ieeecomputersociety.org/},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {nov}
}

@article{ad-haskell,
author = {Krawiec, Faustyna and Peyton Jones, Simon and Krishnaswami, Neel and Ellis, Tom and Eisenberg, Richard A. and Fitzgibbon, Andrew},
title = {Provably correct, asymptotically efficient, higher-order reverse-mode automatic differentiation},
year = {2022},
issue_date = {January 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {6},
number = {POPL},
url = {https://doi.org/10.1145/3498710},
doi = {10.1145/3498710},
abstract = {In this paper, we give a simple and efficient implementation of reverse-mode automatic differentiation, which both extends easily to higher-order functions, and has run time and memory consumption linear in the run time of the original program. In addition to a formal description of the translation, we also describe an implementation of this algorithm, and prove its correctness by means of a logical relations argument.},
journal = {Proc. ACM Program. Lang.},
month = {jan},
articleno = {48},
numpages = {30},
keywords = {Wengert List, Reverse-Mode AD, Higher-Order Functions}
}

@inproceedings{
ad-jax,
title={Automatic Functional Differentiation in {JAX}},
author={Min Lin},
booktitle={The Twelfth International Conference on Learning Representations},
year={2024},
url={https://openreview.net/forum?id=gzT61ziSCu}
}

@inproceedings{ad-tf,
  title={Tensorflow: A system for large-scale machine learning},
  author={Abadi, Mart{\'\i}n and Barham, Paul and Chen, Jianmin and Chen, Zhifeng and Davis, Andy and Dean, Jeffrey and Devin, Matthieu and Ghemawat, Sanjay and Irving, Geoffrey and Isard, Michael and others},
  booktitle={12th $\{$USENIX$\}$ Symposium on Operating Systems Design and Implementation ($\{$OSDI$\}$ 16)},
  pages={265--283},
  year={2016}
}

@inbook{ad-pytorch,
author = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and K\"{o}pf, Andreas and Yang, Edward and DeVito, Zach and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith},
title = {PyTorch: an imperative style, high-performance deep learning library},
year = {2019},
publisher = {Curran Associates Inc.},
address = {Red Hook, NY, USA},
abstract = {Deep learning frameworks have often focused on either usability or speed, but not both. PyTorch is a machine learning library that shows that these two goals are in fact compatible: it provides an imperative and Pythonic programming style that supports code as a model, makes debugging easy and is consistent with other popular scientific computing libraries, while remaining efficient and supporting hardware accelerators such as GPUs.In this paper, we detail the principles that drove the implementation of PyTorch and how they are reflected in its architecture. We emphasize that every aspect of PyTorch is a regular Python program under the full control of its user. We also explain how the careful and pragmatic implementation of the key components of its runtime enables them to work together to achieve compelling performance. We demonstrate the efficiency of individual subsystems, as well as the overall speed of PyTorch on several common benchmarks.},
booktitle = {Proceedings of the 33rd International Conference on Neural Information Processing Systems},
articleno = {721},
numpages = {12}
}

  
@misc{ad-mxnet,
      title={MXNet: A Flexible and Efficient Machine Learning Library for Heterogeneous Distributed Systems}, 
      author={Tianqi Chen and Mu Li and Yutian Li and Min Lin and Naiyan Wang and Minjie Wang and Tianjun Xiao and Bing Xu and Chiyuan Zhang and Zheng Zhang},
      year={2015},
      eprint={1512.01274},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}


@InProceedings{ad-theor1,
author="Cruttwell, Geoffrey S. H.
and Gavranovi{\'{c}}, Bruno
and Ghani, Neil
and Wilson, Paul
and Zanasi, Fabio",
editor="Sergey, Ilya",
title="Categorical Foundations of Gradient-Based Learning",
booktitle="Programming Languages and Systems",
year="2022",
publisher="Springer International Publishing",
address="Cham",
pages="1--28",
abstract="We propose a categorical semantics of gradient-based machine learning algorithms in terms of lenses, parametric maps, and reverse derivative categories. This foundation provides a powerful explanatory and unifying framework: it encompasses a variety of gradient descent algorithms such as ADAM, AdaGrad, and Nesterov momentum, as well as a variety of loss functions such as MSE and Softmax cross-entropy, shedding new light on their similarities and differences. Our approach to gradient-based learning has examples generalising beyond the familiar continuous domains (modelled in categories of smooth maps) and can be realized in the discrete setting of boolean circuits. Finally, we demonstrate the practical significance of our framework with an implementation in Python.",
isbn="978-3-030-99336-8"
}

@inproceedings{ad-theor2,
    author = {Fong, Brendan and Spivak, David and Tuy\'{e}ras, R\'{e}my},
    title = {Backprop as functor: a compositional perspective on supervised learning},
    year = {2021},
    publisher = {IEEE Press},
    abstract = {A supervised learning algorithm searches over a set of functions A → B parametrised by a space P to find the best approximation to some ideal function f: A → B. It does this by taking examples (a,f(a)) ∈ A \texttimes{} B, and updating the parameter according to some rule. We define a category where these update rules may be composed, and show that gradient descent---with respect to a fixed step size and an error function satisfying a certain property---defines a monoidal functor from a category of parametrised functions to this category of update rules. A key contribution is the notion of request function. This provides a structural perspective on backpropagation, giving a broad generalisation of neural networks and linking it with structures from bidirectional programming and open games.},
    booktitle = {Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science},
    articleno = {11},
    numpages = {13},
    location = {Vancouver, Canada},
    series = {LICS '19}
}

      

@article{ad-theor3,
title = {Forward- or reverse-mode automatic differentiation: What's the difference?},
journal = {Science of Computer Programming},
volume = {231},
pages = {103010},
year = {2024},
issn = {0167-6423},
doi = {https://doi.org/10.1016/j.scico.2023.103010},
url = {https://www.sciencedirect.com/science/article/pii/S0167642323000928},
author = {Birthe {van den Berg} and Tom Schrijvers and James McKinna and Alexander Vandenbroucke},
keywords = {Automatic differentiation, Cayley representation, Semimodules, Nagata idealization, Kronecker},
}

@article{ad-elliott,
    author = {Elliott, Conal},
    title = {The simple essence of automatic differentiation},
    year = {2018},
    issue_date = {September 2018},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {ICFP},
    url = {https://doi.org/10.1145/3236765},
    doi = {10.1145/3236765},
    journal = {Proc. ACM Program. Lang.},
    month = {jul},
    articleno = {70},
    numpages = {29},
    keywords = {program calculation, category theory, automatic differentiation}
}

      

@article{sac1,
  title={Shared memory multiprocessor support for functional array processing in SAC},
  volume={15},
  DOI={10.1017/S0956796805005538},
  number={3},
  journal={Journal of Functional Programming},
  author={Grelck, Clemens},
  year={2005},
  pages={353–401}
}


@article{sac2,
  title={Single Assignment C: efficient support for high-level array operations in a functional setting},
  volume={13},
  DOI={10.1017/S0956796802004458},
  number={6},
  journal={Journal of Functional Programming},
  author={Scholz, Sven-Bodo},
  year={2003},
  pages={1005–1059}
}


@Manual{agda-2-6-3,
  title = {Agda 2.6.3 documentation},
  author = {{Agda Development Team}},
  year = 2024,
  url = "https://agda.readthedocs.io/en/v2.6.3/",
  note = {Accessed [2024/02/28]},
}

@inproceedings{rank-poly,
author = {Slepak, Justin and Shivers, Olin and Manolios, Panagiotis},
title = {An Array-Oriented Language with Static Rank Polymorphism},
year = {2014},
isbn = {9783642548321},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
url = {https://doi.org/10.1007/978-3-642-54833-8_3},
doi = {10.1007/978-3-642-54833-8_3},
abstract = {The array-computational model pioneered by Iverson's languages APL and J offers a simple and expressive solution to the "von Neumann bottleneck." It includes a form of rank, or dimensional, polymorphism, which renders much of a program's control structure implicit by lifting base operators to higher-dimensional array structures. We present the first formal semantics for this model, along with the first static type system that captures the full power of the core language.The formal dynamic semantics of our core language, Remora, illuminates several of the murkier corners of the model. This allows us to resolve some of the model's ad hoc elements in more general, regular ways. Among these, we can generalise the model from SIMD to MIMD computations, by extending the semantics to permit functions to be lifted to higher-dimensional arrays in the same way as their arguments.Our static semantics, a dependent type system of carefully restricted power, is capable of describing array computations whose dimensions cannot be determined statically. The type-checking problem is decidable and the type system is accompanied by the usual soundness theorems. Our type system's principal contribution is that it serves to extract the implicit control structure that provides so much of the language's expressive power, making this structure explicitly apparent at compile time.},
booktitle = {Proceedings of the 23rd European Symposium on Programming Languages and Systems - Volume 8410},
pages = {27–46},
numpages = {20}
}


@article{applicative,
  title={Applicative programming with effects},
  volume={18},
  DOI={10.1017/S0956796807006326},
  number={1},
  journal={Journal of Functional Programming},
  author={McBride, Conor and Paterson, Ross},
  year={2008},
  pages={1–13}
}

@inproceedings{type-pattern,
author={Aaldering, Jordy and Scholz, Sven-Bodo and Van Gastel, Bernard},
title={Type Patterns: Pattern Matching on Shape-Carrying Array Types},
publisher={Association for Computing Machinery},
address={New York, NY, USA},
booktitle={Proceedings of the 35st Symposium on Implementation and Application of Functional Languages},
series={IFL '23},
year={2024},
note={(to appear)},
keywords={Array Programming, Single assignment C, Rank-Polymorphism, Hybrid Types, Dependent Types, Type Constraints, Partial Evaluation, Pattern Matching, Shape Pattern, Type Pattern},
abstract={In this paper we present type patterns: a notation for shape-carrying array types that enables the specification of dependent type signatures while maintaining flexibility and a high level of code readability. Similar notations pre-exist, but we extend them to support rank-polymorphism and specifications of arbitrarily complex constraints between values and types. Furthermore, we enable type patterns to double as a pattern matching mechanism against shapes and shape-components of array arguments, making those values directly available in the respective function bodies. While this notation could be used as a basis for a dependently typed language, in our prototypical implementation in the context of SaC we do not require all dependencies to be resolved statically. Instead, we follow a hybrid approach: we map the proposed type patterns into the pre-existing type system of SaC, and we generate additional constraints which we try to statically resolve as far as possible by means of partial evaluation. Any remaining constraints are checked at run-time. We outline our implementation in the context of the SaC ecosystem, and present several examples demonstrating the effectiveness of this hybrid approach based on partial evaluation.}
}

@InProceedings{wlf,
  author     = {Sven-Bodo Scholz},
  title      = {With-loop-folding in Sac --- Condensing Consecutive Array Operations},
  booktitle  = {Implementation of Functional Languages, 9th International Workshop (IFL'97), St. Andrews, UK, Selected Papers},
  year       = {1998},
  editor     = {Chris Clack and Tony Davie and Kevin Hammond},
  volume     = {1467},
  series     = {Lecture Notes in Computer Science},
  pages      = {72--92},
  publisher  = {Springer},
  abstract   = {This paper introduces a new compiler optimization called With-loop-folding. It is based on a special loop construct, the with-loop, which in the functional language SAC (for Single Assignment C) serves as a versatile vehicle to describe array operations on an elementwise basis. A general mechanism for combining two of these With-loops into a single loop construct is presented. This mechanism constitutes a powerful tool when it comes to generate efficiently executable code from high-level array specifications. By means of a few examples it is shown that even complex nestings of array operations similar to those available in Apl can be transformed into single loop operations which are similar to hand-optimized With-loop specifications. As a consequence, the way a complex array operation is combined from primitive array operations does not affect the runtime performance of the compiled code, i.e., the programmer is liberated from the burden to take performance considerations into account when specifying complex array operations.},
  category   = {core,design,opt},
  doi        = {10.1007/BFb0055425},
  isbn       = {978-3-540-64849-9},
  pubaddress = {Berlin, Heidelberg, Germany},
  topics     = {SAC,Avoiding Temporaries,Implementation of Arrays},
  url        = {wlf-st-andrews-97.pdf},
}

