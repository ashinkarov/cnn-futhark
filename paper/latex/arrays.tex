\section{Array Theory\label{sec:array-theory}}

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.List}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{List}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Array}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≤\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{s≤s}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{z≤n}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{+-mono-≤}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≤-step}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{≤-pred}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{+-suc}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{F}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{combine}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{remQuot}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{fromℕ<}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{inject+}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin.Properties}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{suc-injective}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{toℕ<n}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{splitAt-inject+}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaComment{--open\ import\ Fin2\ using\ (Fin;\ \#\AgdaUnderscore{};\ combine;\ remQuot;\ zerof;\ sucf;\ \AgdaUnderscore{}⊕\AgdaUnderscore{};\ \AgdaUnderscore{}⊝\AgdaUnderscore{})}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊎\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Prod}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∃}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{uncurry}\AgdaSymbol{)}\<%
\end{code}

The central data structure of our case study is a multi-dimensional array (ML
uses the term \emph{tensor}).  This section presents a minimalist array theory in Agda
which is well-suited for specifying numerical applications such as CNNs.

The work in the rest of the paper is presented in Agda, with which we assume some
familiarity.
For gentle introductions to Agda we refer to one of the tutorials that are freely available
online.\footnote{See \url{https://agda.readthedocs.io/en/v2.7.0.1/getting-started/tutorial-list.html}.}

The conciseness of the CNN specification
in~\cite{cnn-array} relies on rank-polymorphism, which is the ability to operate
on arrays of arbitrary ranks.  Our array theory is rank polymorphic
which distinguishes it from most existing approaches.
The central consideration when working with dependent types is how to represent data.
Some encodings are better suited for reasoning, others are more efficient
at runtime.  Due to our two-language setup, our choice of representation is
driven by proof considerations only.
This is why we represent arrays as functions from indices to values.

Absence of out-of-bound errors means that all array indices fall within
the shapes of the arrays that they are selecting from.
The shape of array describes the extent of each of its axes.  We represent
shapes as lists of natural numbers using the data type \AD{S}.
The \AC{[]} shape describes an array of rank zero that contains exactly one
element (arrays of such shape are often called \emph{scalars} and we use this
terminology in the rest of the paper).
The cons operation \AC{\_∷\_} prepends a new axis to the left of the shape.
Note on the notation: underscores in \AC{\_∷\_} specify positions where
arguments go, turning \AC{∷} into an infix binary operation.

Array positions (indices) are given by the dependent type \AD{P} which
is indexed by shapes \AD{S}.  A position within an array of shape \AB{s}
is a list of natural numbers of the same length as $s$ where all elements
are less than the corresponding elements of $s$.

Arrays are given by the type \AF{Ar} \AB{s} \AB{X} where $s$ is a shape of the
array and $X$ is the type of array elements. We allow shapes to be empty, in
which case the array represents a scalar. Formal definitions of \AF{S}, \AF{P}
and \AF{Ar} are as follows:

\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{S}\<%
\end{code}
\begin{code}[hide]%
%
\>[2]\AgdaKeyword{variable}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaGeneralizable{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[4]\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaGeneralizable{w}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\<%
\\
%
\>[4]\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{[]}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[4]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}%
\>[9]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaBound{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\end{code}}
\end{mathpar}
The type \AF{Fin} $n$ represents natural numbers bounded by $n$.
As arrays are functions, selections are function applications and
the array constructor is a function definition (\eg{} via $\lambda$-abstraction).

\paragraph{Array Combinators} It is helpful to invest a little time
in defining array combinators.  First, we can observe that \AD{Ar} of
a fixed shape is an applicative functor~\cite{applicative}, so we can trivially derive:
\AF{K}\ \AB{x} to produce a constant array; \AF{map}\ \AB{f}\ \AB{a}
to apply \AB{f} to all the elements of \AB{a}; and \AF{zipWith}\ \AB{f}
\ \AB{a}\ \AB{b} to point-wise apply the binary operation 
\AB{f} to \AB{a} and \AB{b}.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{K}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{K}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
%
\>[2]\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{Z}\<%
\\
%
\>[2]\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}

Array shapes can be concatenated as lists.  We call this operation
\emph{shape product} and we denote it with \AF{\_⊗\_} (because this
corresponds to the shape of tensor product).  Positions of sub-shapes
can be joined into a position of a product shape using the \AF{\_⊗ₚ\_}
operation.  Dually, positions of a product shape can be split into
positions of the corresponding subshapes using \AF{split}.  The types
of these three operations are as follows.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊗\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{S}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊗ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{split}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{p}\<%
\end{code}}
\end{mathpar}
\begin{code}[hide]%
%
\>[2]\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ₚ}}\AgdaSpace{}%
\AgdaBound{jv}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{jv}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{iv}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ₚ}}\AgdaSpace{}%
\AgdaBound{jv}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{iv}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ₚ}}\AgdaSpace{}%
\AgdaBound{jv}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{split}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}%
\>[20]\AgdaBound{is}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{is}\<%
\\
%
\>[2]\AgdaFunction{split}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Prod.map₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{split}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{F.≟}}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≟ₚ}}\AgdaSpace{}%
\AgdaBound{js}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬q}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}

Arrays are homogeneously nested, \ie{} the shapes of all the sub-arrays
have to be the same.  Therefore, we can switch between the array of a product
shape and the nested array (array of arrays).  This operation is very similar
to currying except it happens at the level of shapes.  The combinators that
achieve this are named \AF{nest} and \AF{unnest} and their definitions are:
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{nest}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗ₚ}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code} %
%
\>[2]\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{uncurry}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{split}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}


\paragraph{Reduction} We implement reduction of the binary operations
over arrays in two steps.  Firstly, we define 1-d reductions  that
we call \AD{sum₁} which is similar to right fold on lists.
Arrays of higher ranks iterate \AF{sum₁} bottom-up.  The definition
of the primitives are as follows:
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaKeyword{pattern}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{ιsuc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaFunction{ιsuc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{sum₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{sum₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{\}}%
\>[20]\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{ε}\<%
\\
%
\>[2]\AgdaFunction{sum₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{n}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{\}}%
\>[20]\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sum₁}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{ιsuc}\AgdaSymbol{))}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}%
\>[19]\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{s}\AgdaSymbol{\}}%
\>[19]\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sum₁}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sum}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}

Note that our reduction forces the types of the arguments of the binary
operation to be the same, which is different from usual definitions of foldr.
While this generality is not required for our example,
it is worth noting that the standard behaviour can be recovered\footnote{
We recover regular fold behaviour by running \AD{sum} over function composition:
\begin{code}%
%
\>[2]\AgdaFunction{sum′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{Y}\<%
\\
%
\>[2]\AgdaFunction{sum′}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{ε}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∘′\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{map}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ε}\<%
\end{code}
} through reduction of function composition.

% \paragraph{Reshaping}
% One common operation on arrays is element-preserving change of shape.  We call
% such an operation \AF{reshape}.  It is clear that array elements can be preserved only in
% cases when the number of elements in the original array and the reshaped one
% is the same.  We define an inductive relation \AF{Reshape} that relates
% only those shapes that preserve the number of array elements.  
% \begin{code}[hide]
%   infixr 5 _∙_
%   --infixl 10 _,_
% \end{code}
% \begin{mathpar}
% \codeblock{\begin{code}
%   data Reshape : S → S → Set where
%     eq      : Reshape s s
%     _∙_     : Reshape p q → Reshape s p → Reshape s q
%     _,_     : Reshape s p → Reshape q r → Reshape (s ⊗ q) (p ⊗ r)
%     split   : Reshape (ι (m * n)) (ι m ⊗ ι n)
%     flat    : Reshape (ι m ⊗ ι n) (ι (m * n))
%     swap    : Reshape (s ⊗ p) (p ⊗ s)
%     assocl  : Reshape (s ⊗ (p ⊗ q)) ((s ⊗ p) ⊗ q)
%     assocr  : Reshape ((s ⊗ p) ⊗ q) (s ⊗ (p ⊗ q))
% \end{code}}
% \end{mathpar}
% Any expression $r$ of
% the type (\AF{Reshape} \AB{s} \AB{p}) comes with a straight-forward action on
% indices that we denote \AF{\_⟨\_⟩} (its definition is omitted).
% Such a (contravariant) action translates
% the index within the shape \AB{p} into the index within the shape \AB{s}.
% Given this translation, we can easily define \AF{reshape} as shown below.
% \AF{Reshape} is constructed such that if $s$ and $p$ are related, then 
% $p$ and $s$ are related too.  This fact is given by the function \AF{rev}
% (its definition is omitted) and it immediately implies that all the
% actions on indices as well as array \AF{reshape}s are invertible.
% 
% Note that two shapes can be related by \AF{Reshape} in more than
% one way, which results in different array reshapes.  
% For example, consider \AF{Reshape} (\AC{ι} 5 \AC{⊗} \AC{ι} 4) (\AC{ι} 5 \AC{⊗} \AC{ι} 4)
% given by \AC{swap} or through (\AC{split} \AC{∙} \AC{flat}).  While the former transposes 
% the array elements, the latter does not.
% \begin{mathpar}
% \codeblock{\begin{code}
%   _⟨_⟩ : P p → Reshape s p → P s
% \end{code}}
% \and
% \codeblock{\begin{code}
%   reshape : Reshape s p → Ar s X → Ar p X
%   reshape r a = λ ix → a (ix ⟨ r ⟩)
% \end{code}}
% \and
% \codeblock{\begin{code}
%   rev : Reshape s p → Reshape p s
% \end{code}}
% \end{mathpar}
% From the perspective of category theory, if \AF{S} is an object then \AF{Reshape}
% is a Hom set, where \AC{eq} is identity and \AC{\_∙\_} is a composition with
% the expected properties.  In the language of containers~\cite{containers}, \AF{Ar} is
% a container and \AF{Reshape} is an inductive subset of cartesian container morphisms.
% 


% \begin{code}[hide]
%   i ⟨ eq ⟩ = i
%   (i ⊗ j) ⟨ r , r₁ ⟩ = (i ⟨ r ⟩) ⊗ (j ⟨ r₁ ⟩)
%   i ⟨ r ∙ r₁ ⟩ = i ⟨ r ⟩ ⟨ r₁ ⟩
%   (ι i ⊗ ι j) ⟨ split ⟩ = ι (combine i j)
%   ι i ⟨ flat ⟩ = let a , b = remQuot _ i in ι a ⊗ ι b
%   (i ⊗ j) ⟨ swap ⟩ = j ⊗ i
%   ((i ⊗ j) ⊗ k) ⟨ assocl ⟩ = i ⊗ (j ⊗ k)
%   (i ⊗ (j ⊗ k)) ⟨ assocr ⟩ = (i ⊗ j) ⊗ k
%   
%   
%   rev eq = eq
%   rev (r , r₁) = rev r , rev r₁
%   rev (r ∙ r₁) = rev r₁ ∙ rev r
%   rev split = flat
%   rev flat = split
%   rev swap = swap
%   rev assocl = assocr
%   rev assocr = assocl
% \end{code}


\section{CNN Building Blocks\label{sec:cnn}}

Using the array theory and combinators from the previous section we
define the primitives that are needed for the CNN.

\subsection{One-dimensional convolution}
We start with plus and minus operations for 1-d indices which are
prerequisites for defining convolution:
\begin{code}[hide]%
%
\>[2]\AgdaFunction{inject-left}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaFunction{inject-left}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m}%
\>[44]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{inject+}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
\>[0]\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{inject+}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaInductiveConstructor{zero}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{inspect}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{()}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{()}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{inspect}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\>[2]\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{x}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{r}\AgdaSymbol{)}\<%
\\
\>[0]\<%
\\
%
\>[2]\AgdaFunction{inj₁₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}\{}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{\}\{}\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\>[2]\AgdaFunction{inj₁₂}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\end{code}
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊕\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaInductiveConstructor{zero}%
\>[9]\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{inject-left}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}%
\>[9]\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊝\AgdaUnderscore{}}}%
\>[667I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[667I]%
\>[6]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∃}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
\begin{code}[hide]%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊝\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaFunction{inspect}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{splitAt}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaBound{i}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{split-inj₁}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaBound{r}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{[}}\AgdaSpace{}%
\AgdaBound{r}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaFunction{reason}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{reason}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
%
\>[6]\AgdaFunction{reason}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{splitAt-inject+}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{inj₁₂}\AgdaSpace{}%
\AgdaBound{r}\<%
\\
%
\>[2]\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{())}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝}}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{suc-injective}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{inject-left-zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{inject-left}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaGeneralizable{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaGeneralizable{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\<%
\\
%
\>[2]\AgdaFunction{inject-left-zero}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{suc-not-zero}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\>[2]\AgdaFunction{suc-not-zero}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{inject-left-suc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{inject-left}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaGeneralizable{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaGeneralizable{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\>[2]\AgdaFunction{inject-left-suc}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{+-comm}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{suc-not-zero}\AgdaSpace{}%
\AgdaBound{p}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{zero-suc-⊥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{A}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaInductiveConstructor{zero}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{suc}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
%
\>[2]\AgdaFunction{zero-suc-⊥}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ TODO:\ this\ is\ annoying\ to\ do\ inductively\ on\ Fin,\ it\ is\ easier\ to}\<%
\\
%
\>[2]\AgdaComment{--\ \ \ \ \ \ \ implement\ this\ via\ Fin\ n\ =\ Σ\ ℕ\ (\AgdaUnderscore{}<\ n)\ representation}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ :\ (i\ :\ Fin\ (m\ +\ n))\ →\ (j\ :\ Fin\ (suc\ n))\ →\ Dec\ (∃\ λ\ k\ →\ k\ ⊕\ j\ ≡\ i)}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ \{zero\}\ i\ zero\ =\ no\ λ\ \{\ (()\ ,\ \AgdaUnderscore{})\ \}}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ \{suc\ m\}\ \{n\}\ zero\ zero\ =\ yes\ (zero\ ,\ inject-left-zero\ \{n\}\ \{m\})}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ \{suc\ m\}\ \{n\}\ (suc\ i)\ zero\ with\ minusx\ \{m\}\ i\ zero}\<%
\\
%
\>[2]\AgdaComment{--\ ...\ |\ yes\ (j\ ,\ p)\ =\ yes\ (suc\ j\ ,\ cong\ suc\ p)}\<%
\\
%
\>[2]\AgdaComment{--\ ...\ |\ no\ ¬p\ =\ no\ λ\ \{\ (zero\ ,\ p)\ →\ let\ rr\ =\ trans\ (sym\ \$\ inject-left-zero\ \{n\}\ \{m\})\ p\ }\<%
\\
%
\>[2]\AgdaComment{--\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ in\ zero-suc-⊥\ rr}\<%
\\
%
\>[2]\AgdaComment{--\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;\ (suc\ j\ ,\ p)\ →\ ¬p\ (j\ ,\ suc-injective\ p)\ \}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ minusx\ \{zero\}\ i\ (suc\ j)\ =\ no\ λ\ \{\ (()\ ,\ p)\ \}}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ \{suc\ m\}\ zero\ (suc\ j)\ =\ no\ λ\ \{\ (zero\ ,\ p)\ →\ inject-left-suc\ j\ p}\<%
\\
%
\>[2]\AgdaComment{--\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;\ (suc\ k\ ,\ ())\ \}}\<%
\\
%
\>[2]\AgdaComment{--\ minusx\ \{suc\ m\}\ \{suc\ n\}\ (suc\ i)\ (suc\ j)\ =\ ?\ }\<%
\end{code}
Recall that the type \AF{Fin} $n$ is a type for natural numbers $i$ that
are bounded by $n$ (\ie{} $i < n$).  Plus adds two bounded indices $i$ and $j$
where $i < m$ and $j < 1 + n$ (both $i$ and $j$ are non-negative as any
element of \AF{Fin}).
The indices $i$ and $j$ are added as natural numbers, so there is
no easy way to apply type isomorphisms such as \AD{Fin} $(m + n)$ $\cong$
\AD{Fin} $m$ $⊎$ \AD{Fin} n.  Minus is a partial inverse of plus described below.

While both definitions look innocent, their types carry non-trivial
information about the bounds.  Consider the bounds in the \AF{\_⊕\_} operation:
\begin{mathpar}
  \inferrule*
    {i < m \and j < 1 + n}
    {i+j < m + n}
\end{mathpar}
This looks a little surprising, but this indeed holds for natural numbers.
Readers may convince themselves by considering the maximum value that $i$ and $j$
can possibly take.  The \AF{\_⊕\_} operation have partial inverses making it possible
to define left and right subtraction.  We consider left subtraction \AF{\_⊝\_}.
Its type says that there exists a decision procedure for finding $k$ of type
\AF{Fin} (1 + \AB{n}) (\eg{} $k < 1 + n$) together with the proof that $k$ is
an inverse of \AF{⊕}.
In some sense \AF{Dec} is similar to \AF{Maybe} type, except it forces one
to prove why the value does not exist as opposed to just returning \AC{nothing}.
For example, if we were to evaluate $i ⊝ j$ where $i = 1 < 3 + 5$ and $j = 2 < 3$,
we will get a proof that there is no natural number $k < 1 + 5$ such that $2 ⊕ k ≡ 1$.
Here dependent types come very useful, as we eliminate the possibility of
introducing off-by-one errors in the definition of \AF{⊝}.


Now we are ready to define a 1-dimensional convolution.
A side note for mathematically inclined readers: we use the term
\emph{convolution} in the way it is used in machine learning.  Technically,
we compute a cross-correlation, because the array of weights is not flipped.
However, in practice this is not a problem, as we assume that weights are
stored flipped in memory.

We define type synonyms \AF{Vec} and \AF{Ix} which are 1-dimensional versions
of \AF{Ar} and \AF{P}.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{X}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{Ix}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaFunction{Ix}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
We introduce the \AF{slide₁} primitive that selects a $(1+n)$-element vector
from the $(m+n)$-element vector starting at the offset $i$.  Then,
following~\cite{cnn-array}, we compute $m$-element array of slides
and then sum it up.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{slide₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ix}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{slide₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ι}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{conv₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Vec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaDatatype{ℕ}\<%
\\
%
\>[2]\AgdaFunction{conv₁}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{K}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{slide₁}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{))}\<%
\end{code}}
\end{mathpar}
Note that in the definition of \AF{conv₁} we use a standard array language
trick --- we pull summation to the outside.  For example, for $m = 3$, $n = 2$,
a straight-forward way to compute (\AF{conv₁} $[a_1, a_2, a_3, a_4, a_5]$
$[w_1, w_2, w_3]$) would be $[a_1w_1 + a_2w_2 + a_3w_3, a_2w_1 + a_3w_2 +
a_4w_3,\dots]$.  However, the above definition proceeds as $w_1[a_1,a_2,a_3] +
w_2[a_2,a_3,a_4] + w_3[a_3,a_4,a_5]$ which computes the same result.  Such
definition makes it easy to replace the implementation of slide, obtaining
other versions of convolution such as the one with constant or cyclic
boundaries.  As we demonstrate in the next section, this pattern generalises
nicely to higher ranks.



\subsection{Generalisation\label{sec:general-ix-ops}}
Now we generalise 1-dimensional slide for arrays of higher ranks.
This requires generalising vector shapes $m + n$ and $1 + n$ for the cases
when $m$ and $n$ for arbitrary shapes.  In case of addition, we need a witness
that both shapes
have the same length.  If they do, their components are added point-wise.
We define a three-way relation \AF{\_+\_≈\_} that combines the witness and
the action.  That is, the type \AB{p} \AF{+} \AB{q} \AF{≈} \AB{r} says that
$p$ and $q$ have the same length and that $r$ is a point-wise addition
of $p$ and $q$.  A similar relation \AF{suc\_≈\_} is introduced for $1 + n$
case, and \AF{\_*\_≈\_} witnesses point-wise
multiplication that will be needed for blocking.  We define these relations
in two steps.  Firstly, we give a generalised pointwise relations for binary
and ternary relations on natural numbers:
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaKeyword{data}%
\>[956I]\AgdaDatatype{Pw₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[956I]%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}%
\AgdaKeyword{instance}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaInductiveConstructor{[]}%
\>[12]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pw₂}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[6]\AgdaInductiveConstructor{cons}%
\>[12]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaDatatype{Pw₂}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{⦄}\<%
\\
%
\>[12]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pw₂}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaKeyword{data}%
\>[997I]\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[997I]%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\AgdaSpace{}%
\AgdaKeyword{instance}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaInductiveConstructor{[]}%
\>[12]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\<%
\\
%
\>[6]\AgdaInductiveConstructor{cons}%
\>[12]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaGeneralizable{k}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{⦄}\<%
\\
%
\>[12]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaBound{R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
While the definition is straight-forward, note that we mark constructors
with the keyword \AK{instance} and we turn the arguments of \AC{cons}
into instance arguments\footnote{See \url{https://agda.readthedocs.io/en/v2.7.0.1/language/instance-arguments.html} for more details.}.  These arguments
behave like the hidden arguments, except Agda will apply an instance
search when solving them.  This allows us to omit these proofs in
a larger number of cases than if we were to use hidden arguments.

\begin{code}[hide]%
%
\>[2]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}+\AgdaUnderscore{}≈\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc\AgdaUnderscore{}≈\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}*\AgdaUnderscore{}≈\AgdaUnderscore{}}}\<%
\\
%
\>[2]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{8}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊝ₚ\AgdaUnderscore{}}}\<%
\end{code}

The second step is to define the actual relations.  With the help of composition
combinators ($f$ \AF{∘} $g$ = λ x → $f$ ($g$ x)) and ($f$ \AF{∘₂} $g$ = λ x y → $f$ ($g$ x y))
the definitions are as follows.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}+\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}+\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘₂}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}*\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}*\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Pw₃}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘₂}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{suc\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{s}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{S}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{suc\AgdaUnderscore{}≈\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Pw₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}

With these relations in place, we could define generalised convolution
similarly to \AF{sum} where we recurse over the shape, performing one
operation at a time.  However, there is a good point made
in~\cite{cnn-array} about shifting the shape recursion into index computation.
% Talk about mental model of runtime where arrays are flat and indices are offsets
Therefore we define \AF{\_⊕ₚ\_} and \AF{\_⊝ₚ\_} which generalise \AF{\_⊕\_} and
\AF{\_⊝\_} for higher ranks.  Once again, \AD{Dec} type forces \AF{⊝ₚ} to justify
the cases when the inverse does not exist.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊕ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{r}\<%
\\
%
\>[2]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊝ₚ\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{su}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{sp}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{∃}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{k}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕ₚ}}\AgdaSpace{}%
\AgdaBound{k}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
The implementations of \AF{⊕ₚ} and \AF{⊝ₚ} simply apply \AF{⊕} and \AF{⊝}.
In the \AF{⊝} case a little plumbing is required when constructing the
proof of (non-)existence of the inverse.
\begin{code}[hide]%
%
\>[2]\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕ₚ}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕ₚ}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaSymbol{⦄)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{s+p}\AgdaSpace{}%
\AgdaSymbol{⦄)}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{is}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕ₚ}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaBound{s+p}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝ₚ}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}%
\>[1192I]\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝ₚ}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaSymbol{⦄)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{s+p}\AgdaSpace{}%
\AgdaSymbol{⦄)}\<%
\\
\>[.][@{}l@{}]\<[1192I]%
\>[8]\AgdaKeyword{with}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝}}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬p}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{is}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝ₚ}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaBound{s+p}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaBound{¬q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaSymbol{((\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{xs}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{¬q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{xs}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ks}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{ks}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{cong₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}∷\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\end{code}

Generalised \AF{slide} looks very similar to its 1-dimensional
counterpart, except that \AF{⊕} is replaced with \AF{⊕ₚ}
We also introduce a section of \AF{slide} that we call \AF{backslide}.
It embeds a $(1+p)$-dimensional array into a $(s+p)$-dimensional
one at the offset $i$ using \AB{def} to fill the outer region.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{slide}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{slide}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{pl}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊕ₚ}}\AgdaSpace{}%
\AgdaBound{j}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaBound{pl}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{backslide}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{def}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{backslide}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaBound{def}\AgdaSpace{}%
\AgdaBound{pl}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaKeyword{with}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊝ₚ}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaBound{pl}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{...}\AgdaSpace{}%
\AgdaSymbol{|}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{k}\<%
\\
%
\>[2]\AgdaCatchallClause{\AgdaSymbol{...}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{|}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{}}}%
\>[21]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{def}\<%
\end{code}}
\end{mathpar}

\paragraph{Remark on indexing} We would like to address a general remark that
is often made by functional programmers that index-oriented definitions such as
\AF{slide} and \AF{backslide} should be replaced by some construction that use
algebraic data types.  While this is of course a matter of taste, here are
important points that justify our choice. Firstly, array computations that use
explicit indices are easier to compile into efficient code. At runtime, arrays
will be represented as flat regions of memory without cons cells or other
pointer-connected structures. Index computations will be turned into offset
computations that are efficient on most architectures.  Secondly, many
rank-polymorphic operations on arrays are easier to express via index
manipulation (our indices have non-trivial structure) rather than via
traversals of algebraic data structures.  For example, consider a data
structure for a rank-polymorphic array similar to \AD{Ar}.  One needs something
like a free monad over a \AD{Vec} type, which can be easily defined.  Now,
consider defining a generalised transpose on such representation.  Transpose of
an \AD{Ar} array is simply a selection on a reversed index: λ ix → a
(\AF{reverse} ix). In case of free monads, this is a significantly more
complicated recursive expression.  Finally, when arrays are
functions, fusion equalities (\eg{} map f ∘ map g $\cong$ map (f ∘ g))
come for free through normalisation, which makes formal reasoning easier.





\subsection{CNN primitives\label{sec:ar-cnn-prim}}
Here we implement CNN-specific primitives that are needed for our running example.
All these primitives operate on arrays of reals.  We use builtin Agda floats in
the rest of the section that we refer to as \AD{ℝ}.  The only reason for this
is the ability to evaluate our specification with concrete values.
Later we are going to abstract over concrete implementation of \AD{ℝ}.

Generalised convolution is given by \AF{conv}, and it is almost identical to its
1-dimensional counterpart (except it uses \AF{slide} instead of \AF{slide₁}).
The \AF{mconv} runs $u$ \AF{conv}s (conceptually in parallel) and then it adds a
corresponding bias from the array $b$ (of shape $u$) to each convolution.
\begin{code}[hide]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{CNN}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{ℕ}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Float}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{F}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{\AgdaUnderscore{}*\AgdaUnderscore{}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{\AgdaUnderscore{}÷\AgdaUnderscore{}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{e\textasciicircum{}\AgdaUnderscore{}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{-\AgdaUnderscore{}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaPrimitive{fromℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{Float}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Prod}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{()}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Fin}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{F}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{zero}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{suc}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaDatatype{Fin}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{combine}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{remQuot}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{fromℕ<}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{inject+}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{splitAt}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Array}\<%
\end{code}

\begin{code}%
%
\>[2]\AgdaFunction{conv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[2]\AgdaFunction{conv}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{zipWith}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{K}\AgdaSpace{}%
\AgdaNumber{0.0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{*\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{slide}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{su}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{mconv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{+}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{r}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{suc}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{u}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊗}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[2]\AgdaFunction{mconv}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaBound{inp}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{su}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{conv}\AgdaSpace{}%
\AgdaBound{sp}\AgdaSpace{}%
\AgdaBound{inp}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{w}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{su}\AgdaSymbol{)}\<%
\end{code}
The logistic function computes ${1}/(1 + e^{-x})$ for every element in the array.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{logistic}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[2]\AgdaFunction{logistic}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaNumber{1.0}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{÷}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{1.0}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{+}}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{e\textasciicircum{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaPrimitive{-}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\end{code}}
\end{mathpar}

\paragraph{Average Pooling}
One of the steps of the machine learning algorithm is average pooling which
splits an array into sub-blocks and computes the average for every such
block.  Implementing this pattern generally is tricky as we have to
preserve the local neighbourhood within the blocks.  Working with a
blocked array would be inconvenient as the blocked shape
does not go well with \AF{slides}.  We solve this by introducing
blocked selections \AF{selb} into arrays of shape $(s * p)$ as well
as blocked array constructor \AF{imapb} that builds an array of
shape $(s * p)$ out of $s$ blocks of shape $p$.  Defining these
operations we require pairing and projections of the blocked indices
which is achieved by applying division and modulo operation on the
components.  The types of these operations are as follows:
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{ix-div}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{ix-mod}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{p}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{ix-combine}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{q}\<%
\end{code}}
\end{mathpar}
\begin{code}[hide]%
%
\>[2]\AgdaFunction{ix-div}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{is}\<%
\\
%
\>[2]\AgdaFunction{ix-div}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{pf}\AgdaSpace{}%
\AgdaSymbol{⦄)}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{Prod.proj₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{F.remQuot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{ix-div}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaBound{pf}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{ix-mod}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{is}\<%
\\
%
\>[2]\AgdaFunction{ix-mod}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{pf}\AgdaSpace{}%
\AgdaSymbol{⦄)}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{Prod.proj₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{F.remQuot}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{m}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{i}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{ix-mod}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaBound{pf}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{ix-combine}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{j}\<%
\\
%
\>[2]\AgdaFunction{ix-combine}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{i}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{is}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{js}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{cons}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{⦄}\AgdaSpace{}%
\AgdaSymbol{⦃}\AgdaSpace{}%
\AgdaBound{ps}\AgdaSpace{}%
\AgdaSymbol{⦄)}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{F.combine}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaFunction{ix-combine}\AgdaSpace{}%
\AgdaBound{is}\AgdaSpace{}%
\AgdaBound{js}\AgdaSpace{}%
\AgdaBound{ps}\<%
\end{code}
With these operations, definitions of \AF{selb} and \AF{imapb}
are:

\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{selb}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{P}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{selb}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ix-combine}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{j}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}}
\and
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{imapb}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaGeneralizable{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{s}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{*}}\AgdaSpace{}%
\AgdaGeneralizable{p}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≈}}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaGeneralizable{q}\AgdaSpace{}%
\AgdaGeneralizable{X}\<%
\\
%
\>[2]\AgdaFunction{imapb}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ix-div}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ix-mod}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaBound{p}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
We define an average pooling that is specialised to
2-dimensional cases as needed per our running example.
\begin{mathpar}
\codeblock{\begin{code}%
%
\>[2]\AgdaFunction{avgp₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{ℕ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{ℕ.*}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{ℕ.*}}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[2]\AgdaFunction{avgp₂}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaBound{n}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}÷}}\AgdaSpace{}%
\AgdaPrimitive{fromℕ}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{sum}\AgdaSpace{}%
\AgdaOperator{\AgdaPrimitive{\AgdaUnderscore{}+\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaNumber{0.0}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{selb}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaFunction{it}\AgdaSymbol{)}\<%
\end{code}}
\end{mathpar}
Note that \AF{avgp₂} forces a programmer to provide explicit sizes
of the blocked array, and it will not admit arrays of shape such as
$2 * m \times 2 * n$, because $m * 2$ is not definitionally equal to $2 * m$.

With these primitives we implement a forward part of the CNN
as follows.  The \AB{inp} argument is the image of a hand-written digit, all
the other arguments are weights, and the function returns the 10-element vector
with probabilities which digit that is.  Note that type annotations in let are
purely for documentation --- Agda infers them automatically and these lines
can be removed.  Note also that all the \AF{mconv} applications do not require
explicit proofs as Agda can compute them from the shape information provided
in types.
%\begin{mathpar}
%\codeblock{
\begin{code}%
%
\>[2]\AgdaFunction{forward}%
\>[1733I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{inp}%
\>[18]\AgdaSymbol{:}%
\>[21]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{28}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{28}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}\<%
\\
\>[.][@{}l@{}]\<[1733I]%
\>[10]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b₁}%
\>[18]\AgdaSymbol{:}%
\>[21]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{6}%
\>[28]\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}%
\>[42]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{k₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}\<%
\\
%
\>[10]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b₂}%
\>[18]\AgdaSymbol{:}%
\>[21]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}%
\>[42]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{fc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{10}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}\<%
\\
%
\>[10]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{b}%
\>[18]\AgdaSymbol{:}%
\>[21]\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{10}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\AgdaSymbol{)}%
\>[42]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{10}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[2]\AgdaFunction{forward}\AgdaSpace{}%
\AgdaBound{inp}\AgdaSpace{}%
\AgdaBound{k₁}\AgdaSpace{}%
\AgdaBound{b₁}\AgdaSpace{}%
\AgdaBound{k₂}\AgdaSpace{}%
\AgdaBound{b₂}\AgdaSpace{}%
\AgdaBound{fc}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{let}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaBound{c₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{24}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{24}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[6]\AgdaBound{c₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{logistic}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{mconv}\AgdaSpace{}%
\AgdaBound{inp}\AgdaSpace{}%
\AgdaBound{k₁}\AgdaSpace{}%
\AgdaBound{b₁}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaBound{s₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[6]\AgdaBound{s₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{6}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{avgp₂}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{c₁}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaBound{c₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{8}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{8}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[6]\AgdaBound{c₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{logistic}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{mconv}%
\>[29]\AgdaBound{s₁}\AgdaSpace{}%
\AgdaBound{k₂}\AgdaSpace{}%
\AgdaBound{b₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaBound{s₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Ar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaPostulate{ℝ}\<%
\\
%
\>[6]\AgdaBound{s₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{unnest}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{s}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaNumber{12}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{∷}}\AgdaSpace{}%
\AgdaInductiveConstructor{[]}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{map}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{avgp₂}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSpace{}%
\AgdaNumber{4}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{nest}\AgdaSpace{}%
\AgdaBound{c₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[6]\AgdaBound{r}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{logistic}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaFunction{mconv}\AgdaSpace{}%
\AgdaBound{s₂}\AgdaSpace{}%
\AgdaBound{fc}\AgdaSpace{}%
\AgdaBound{b}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{in}\AgdaSpace{}%
\AgdaBound{r}\<%
\end{code}
%}
%\end{mathpar}

